/**
 * Minified by jsDelivr using Terser v5.7.1.
 * Original file: /npm/pdfkit@0.13.0/js/pdfkit.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict"; var stream = require("stream"), fs = require("fs"), zlib = require("zlib"), CryptoJS = require("crypto-js"), fontkit = require("fontkit"), events = require("events"), LineBreaker = require("linebreak"), PNG = require("png-js"); class PDFAbstractReference { toString() { throw new Error("Must be implemented by subclasses") } } class PDFTree { constructor(t = {}) { this._items = {}, this.limits = "boolean" != typeof t.limits || t.limits } add(t, e) { return this._items[t] = e } get(t) { return this._items[t] } toString() { const t = Object.keys(this._items).sort(((t, e) => this._compareKeys(t, e))), e = ["<<"]; if (this.limits && t.length > 1) { const i = t[0], n = t[t.length - 1]; e.push(`  /Limits ${PDFObject.convert([this._dataForKey(i), this._dataForKey(n)])}`) } e.push(`  /${this._keysName()} [`); for (let i of t) e.push(`    ${PDFObject.convert(this._dataForKey(i))} ${PDFObject.convert(this._items[i])}`); return e.push("]"), e.push(">>"), e.join("\n") } _compareKeys() { throw new Error("Must be implemented by subclasses") } _keysName() { throw new Error("Must be implemented by subclasses") } _dataForKey() { throw new Error("Must be implemented by subclasses") } } const pad = (t, e) => (Array(e + 1).join("0") + t).slice(-e), escapableRe = /[\n\r\t\b\f()\\]/g, escapable = { "\n": "\\n", "\r": "\\r", "\t": "\\t", "\b": "\\b", "\f": "\\f", "\\": "\\\\", "(": "\\(", ")": "\\)" }, swapBytes = function (t) { const e = t.length; if (1 & e) throw new Error("Buffer length must be even"); for (let i = 0, n = e - 1; i < n; i += 2) { const e = t[i]; t[i] = t[i + 1], t[i + 1] = e } return t }; class PDFObject { static convert(t, e = null) { if ("string" == typeof t) return `/${t}`; if (t instanceof String) { let i, n = t, r = !1; for (let t = 0, e = n.length; t < e; t++)if (n.charCodeAt(t) > 127) { r = !0; break } return i = r ? swapBytes(Buffer.from(`\ufeff${n}`, "utf16le")) : Buffer.from(n.valueOf(), "ascii"), n = e ? e(i).toString("binary") : i.toString("binary"), n = n.replace(escapableRe, (t => escapable[t])), `(${n})` } if (Buffer.isBuffer(t)) return `<${t.toString("hex")}>`; if (t instanceof PDFAbstractReference || t instanceof PDFTree) return t.toString(); if (t instanceof Date) { let i = `D:${pad(t.getUTCFullYear(), 4)}` + pad(t.getUTCMonth() + 1, 2) + pad(t.getUTCDate(), 2) + pad(t.getUTCHours(), 2) + pad(t.getUTCMinutes(), 2) + pad(t.getUTCSeconds(), 2) + "Z"; return e && (i = e(Buffer.from(i, "ascii")).toString("binary"), i = i.replace(escapableRe, (t => escapable[t]))), `(${i})` } if (Array.isArray(t)) { return `[${t.map((t => PDFObject.convert(t, e))).join(" ")}]` } if ("[object Object]" === {}.toString.call(t)) { const i = ["<<"]; for (let n in t) { const r = t[n]; i.push(`/${n} ${PDFObject.convert(r, e)}`) } return i.push(">>"), i.join("\n") } return "number" == typeof t ? PDFObject.number(t) : `${t}` } static number(t) { if (t > -1e21 && t < 1e21) return Math.round(1e6 * t) / 1e6; throw new Error(`unsupported number: ${t}`) } } class PDFReference extends PDFAbstractReference { constructor(t, e, i = {}) { super(), this.document = t, this.id = e, this.data = i, this.gen = 0, this.compress = this.document.compress && !this.data.Filter, this.uncompressedLength = 0, this.buffer = [] } write(t) { if (Buffer.isBuffer(t) || (t = Buffer.from(t + "\n", "binary")), this.uncompressedLength += t.length, null == this.data.Length && (this.data.Length = 0), this.buffer.push(t), this.data.Length += t.length, this.compress) return this.data.Filter = "FlateDecode" } end(t) { return t && this.write(t), this.finalize() } finalize() { this.offset = this.document._offset; const t = this.document._security ? this.document._security.getEncryptFn(this.id, this.gen) : null; this.buffer.length && (this.buffer = Buffer.concat(this.buffer), this.compress && (this.buffer = zlib.deflateSync(this.buffer)), t && (this.buffer = t(this.buffer)), this.data.Length = this.buffer.length), this.document._write(`${this.id} ${this.gen} obj`), this.document._write(PDFObject.convert(this.data, t)), this.buffer.length && (this.document._write("stream"), this.document._write(this.buffer), this.buffer = [], this.document._write("\nendstream")), this.document._write("endobj"), this.document._refEnd(this) } toString() { return `${this.id} ${this.gen} R` } } const DEFAULT_MARGINS = { top: 72, left: 72, bottom: 72, right: 72 }, SIZES = { "4A0": [4767.87, 6740.79], "2A0": [3370.39, 4767.87], A0: [2383.94, 3370.39], A1: [1683.78, 2383.94], A2: [1190.55, 1683.78], A3: [841.89, 1190.55], A4: [595.28, 841.89], A5: [419.53, 595.28], A6: [297.64, 419.53], A7: [209.76, 297.64], A8: [147.4, 209.76], A9: [104.88, 147.4], A10: [73.7, 104.88], B0: [2834.65, 4008.19], B1: [2004.09, 2834.65], B2: [1417.32, 2004.09], B3: [1000.63, 1417.32], B4: [708.66, 1000.63], B5: [498.9, 708.66], B6: [354.33, 498.9], B7: [249.45, 354.33], B8: [175.75, 249.45], B9: [124.72, 175.75], B10: [87.87, 124.72], C0: [2599.37, 3676.54], C1: [1836.85, 2599.37], C2: [1298.27, 1836.85], C3: [918.43, 1298.27], C4: [649.13, 918.43], C5: [459.21, 649.13], C6: [323.15, 459.21], C7: [229.61, 323.15], C8: [161.57, 229.61], C9: [113.39, 161.57], C10: [79.37, 113.39], RA0: [2437.8, 3458.27], RA1: [1729.13, 2437.8], RA2: [1218.9, 1729.13], RA3: [864.57, 1218.9], RA4: [609.45, 864.57], SRA0: [2551.18, 3628.35], SRA1: [1814.17, 2551.18], SRA2: [1275.59, 1814.17], SRA3: [907.09, 1275.59], SRA4: [637.8, 907.09], EXECUTIVE: [521.86, 756], FOLIO: [612, 936], LEGAL: [612, 1008], LETTER: [612, 792], TABLOID: [792, 1224] }; class PDFPage { constructor(t, e = {}) { this.document = t, this.size = e.size || "letter", this.layout = e.layout || "portrait", "number" == typeof e.margin ? this.margins = { top: e.margin, left: e.margin, bottom: e.margin, right: e.margin } : this.margins = e.margins || DEFAULT_MARGINS; const i = Array.isArray(this.size) ? this.size : SIZES[this.size.toUpperCase()]; this.width = i["portrait" === this.layout ? 0 : 1], this.height = i["portrait" === this.layout ? 1 : 0], this.content = this.document.ref(), this.resources = this.document.ref({ ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"] }), this.dictionary = this.document.ref({ Type: "Page", Parent: this.document._root.data.Pages, MediaBox: [0, 0, this.width, this.height], Contents: this.content, Resources: this.resources }), this.markings = [] } get fonts() { const t = this.resources.data; return null != t.Font ? t.Font : t.Font = {} } get xobjects() { const t = this.resources.data; return null != t.XObject ? t.XObject : t.XObject = {} } get ext_gstates() { const t = this.resources.data; return null != t.ExtGState ? t.ExtGState : t.ExtGState = {} } get patterns() { const t = this.resources.data; return null != t.Pattern ? t.Pattern : t.Pattern = {} } get colorSpaces() { const t = this.resources.data; return t.ColorSpace || (t.ColorSpace = {}) } get annotations() { const t = this.dictionary.data; return null != t.Annots ? t.Annots : t.Annots = [] } get structParentTreeKey() { const t = this.dictionary.data; return null != t.StructParents ? t.StructParents : t.StructParents = this.document.createStructParentTreeNextKey() } maxY() { return this.height - this.margins.bottom } write(t) { return this.content.write(t) } end() { return this.dictionary.end(), this.resources.end(), this.content.end() } } class PDFNameTree extends PDFTree { _compareKeys(t, e) { return t.localeCompare(e) } _keysName() { return "Names" } _dataForKey(t) { return new String(t) } } function inRange(t, e) { if (t < e[0]) return !1; let i = 0, n = e.length / 2; for (; i <= n;) { const r = Math.floor((i + n) / 2), s = 2 * r; if (t >= e[s] && t <= e[s + 1]) return !0; t > e[s + 1] ? i = r + 1 : n = r - 1 } return !1 } const unassigned_code_points = [545, 545, 564, 591, 686, 687, 751, 767, 848, 863, 880, 883, 886, 889, 891, 893, 895, 899, 907, 907, 909, 909, 930, 930, 975, 975, 1015, 1023, 1159, 1159, 1231, 1231, 1270, 1271, 1274, 1279, 1296, 1328, 1367, 1368, 1376, 1376, 1416, 1416, 1419, 1424, 1442, 1442, 1466, 1466, 1477, 1487, 1515, 1519, 1525, 1547, 1549, 1562, 1564, 1566, 1568, 1568, 1595, 1599, 1622, 1631, 1774, 1775, 1791, 1791, 1806, 1806, 1837, 1839, 1867, 1919, 1970, 2304, 2308, 2308, 2362, 2363, 2382, 2383, 2389, 2391, 2417, 2432, 2436, 2436, 2445, 2446, 2449, 2450, 2473, 2473, 2481, 2481, 2483, 2485, 2490, 2491, 2493, 2493, 2501, 2502, 2505, 2506, 2510, 2518, 2520, 2523, 2526, 2526, 2532, 2533, 2555, 2561, 2563, 2564, 2571, 2574, 2577, 2578, 2601, 2601, 2609, 2609, 2612, 2612, 2615, 2615, 2618, 2619, 2621, 2621, 2627, 2630, 2633, 2634, 2638, 2648, 2653, 2653, 2655, 2661, 2677, 2688, 2692, 2692, 2700, 2700, 2702, 2702, 2706, 2706, 2729, 2729, 2737, 2737, 2740, 2740, 2746, 2747, 2758, 2758, 2762, 2762, 2766, 2767, 2769, 2783, 2785, 2789, 2800, 2816, 2820, 2820, 2829, 2830, 2833, 2834, 2857, 2857, 2865, 2865, 2868, 2869, 2874, 2875, 2884, 2886, 2889, 2890, 2894, 2901, 2904, 2907, 2910, 2910, 2914, 2917, 2929, 2945, 2948, 2948, 2955, 2957, 2961, 2961, 2966, 2968, 2971, 2971, 2973, 2973, 2976, 2978, 2981, 2983, 2987, 2989, 2998, 2998, 3002, 3005, 3011, 3013, 3017, 3017, 3022, 3030, 3032, 3046, 3059, 3072, 3076, 3076, 3085, 3085, 3089, 3089, 3113, 3113, 3124, 3124, 3130, 3133, 3141, 3141, 3145, 3145, 3150, 3156, 3159, 3167, 3170, 3173, 3184, 3201, 3204, 3204, 3213, 3213, 3217, 3217, 3241, 3241, 3252, 3252, 3258, 3261, 3269, 3269, 3273, 3273, 3278, 3284, 3287, 3293, 3295, 3295, 3298, 3301, 3312, 3329, 3332, 3332, 3341, 3341, 3345, 3345, 3369, 3369, 3386, 3389, 3396, 3397, 3401, 3401, 3406, 3414, 3416, 3423, 3426, 3429, 3440, 3457, 3460, 3460, 3479, 3481, 3506, 3506, 3516, 3516, 3518, 3519, 3527, 3529, 3531, 3534, 3541, 3541, 3543, 3543, 3552, 3569, 3573, 3584, 3643, 3646, 3676, 3712, 3715, 3715, 3717, 3718, 3721, 3721, 3723, 3724, 3726, 3731, 3736, 3736, 3744, 3744, 3748, 3748, 3750, 3750, 3752, 3753, 3756, 3756, 3770, 3770, 3774, 3775, 3781, 3781, 3783, 3783, 3790, 3791, 3802, 3803, 3806, 3839, 3912, 3912, 3947, 3952, 3980, 3983, 3992, 3992, 4029, 4029, 4045, 4046, 4048, 4095, 4130, 4130, 4136, 4136, 4139, 4139, 4147, 4149, 4154, 4159, 4186, 4255, 4294, 4303, 4345, 4346, 4348, 4351, 4442, 4446, 4515, 4519, 4602, 4607, 4615, 4615, 4679, 4679, 4681, 4681, 4686, 4687, 4695, 4695, 4697, 4697, 4702, 4703, 4743, 4743, 4745, 4745, 4750, 4751, 4783, 4783, 4785, 4785, 4790, 4791, 4799, 4799, 4801, 4801, 4806, 4807, 4815, 4815, 4823, 4823, 4847, 4847, 4879, 4879, 4881, 4881, 4886, 4887, 4895, 4895, 4935, 4935, 4955, 4960, 4989, 5023, 5109, 5120, 5751, 5759, 5789, 5791, 5873, 5887, 5901, 5901, 5909, 5919, 5943, 5951, 5972, 5983, 5997, 5997, 6001, 6001, 6004, 6015, 6109, 6111, 6122, 6143, 6159, 6159, 6170, 6175, 6264, 6271, 6314, 7679, 7836, 7839, 7930, 7935, 7958, 7959, 7966, 7967, 8006, 8007, 8014, 8015, 8024, 8024, 8026, 8026, 8028, 8028, 8030, 8030, 8062, 8063, 8117, 8117, 8133, 8133, 8148, 8149, 8156, 8156, 8176, 8177, 8181, 8181, 8191, 8191, 8275, 8278, 8280, 8286, 8292, 8297, 8306, 8307, 8335, 8351, 8370, 8399, 8427, 8447, 8507, 8508, 8524, 8530, 8580, 8591, 9167, 9215, 9255, 9279, 9291, 9311, 9471, 9471, 9748, 9749, 9752, 9752, 9854, 9855, 9866, 9984, 9989, 9989, 9994, 9995, 10024, 10024, 10060, 10060, 10062, 10062, 10067, 10069, 10071, 10071, 10079, 10080, 10133, 10135, 10160, 10160, 10175, 10191, 10220, 10223, 11008, 11903, 11930, 11930, 12020, 12031, 12246, 12271, 12284, 12287, 12352, 12352, 12439, 12440, 12544, 12548, 12589, 12592, 12687, 12687, 12728, 12783, 12829, 12831, 12868, 12880, 12924, 12926, 13004, 13007, 13055, 13055, 13175, 13178, 13278, 13279, 13311, 13311, 19894, 19967, 40870, 40959, 42125, 42127, 42183, 44031, 55204, 55295, 64046, 64047, 64107, 64255, 64263, 64274, 64280, 64284, 64311, 64311, 64317, 64317, 64319, 64319, 64322, 64322, 64325, 64325, 64434, 64466, 64832, 64847, 64912, 64913, 64968, 64975, 65021, 65023, 65040, 65055, 65060, 65071, 65095, 65096, 65107, 65107, 65127, 65127, 65132, 65135, 65141, 65141, 65277, 65278, 65280, 65280, 65471, 65473, 65480, 65481, 65488, 65489, 65496, 65497, 65501, 65503, 65511, 65511, 65519, 65528, 65536, 66303, 66335, 66335, 66340, 66351, 66379, 66559, 66598, 66599, 66638, 118783, 119030, 119039, 119079, 119081, 119262, 119807, 119893, 119893, 119965, 119965, 119968, 119969, 119971, 119972, 119975, 119976, 119981, 119981, 119994, 119994, 119996, 119996, 120001, 120001, 120004, 120004, 120070, 120070, 120075, 120076, 120085, 120085, 120093, 120093, 120122, 120122, 120127, 120127, 120133, 120133, 120135, 120137, 120145, 120145, 120484, 120487, 120778, 120781, 120832, 131069, 173783, 194559, 195102, 196605, 196608, 262141, 262144, 327677, 327680, 393213, 393216, 458749, 458752, 524285, 524288, 589821, 589824, 655357, 655360, 720893, 720896, 786429, 786432, 851965, 851968, 917501, 917504, 917504, 917506, 917535, 917632, 983037], isUnassignedCodePoint = t => inRange(t, unassigned_code_points), commonly_mapped_to_nothing = [173, 173, 847, 847, 6150, 6150, 6155, 6155, 6156, 6156, 6157, 6157, 8203, 8203, 8204, 8204, 8205, 8205, 8288, 8288, 65024, 65024, 65025, 65025, 65026, 65026, 65027, 65027, 65028, 65028, 65029, 65029, 65030, 65030, 65031, 65031, 65032, 65032, 65033, 65033, 65034, 65034, 65035, 65035, 65036, 65036, 65037, 65037, 65038, 65038, 65039, 65039, 65279, 65279], isCommonlyMappedToNothing = t => inRange(t, commonly_mapped_to_nothing), non_ASCII_space_characters = [160, 160, 5760, 5760, 8192, 8192, 8193, 8193, 8194, 8194, 8195, 8195, 8196, 8196, 8197, 8197, 8198, 8198, 8199, 8199, 8200, 8200, 8201, 8201, 8202, 8202, 8203, 8203, 8239, 8239, 8287, 8287, 12288, 12288], isNonASCIISpaceCharacter = t => inRange(t, non_ASCII_space_characters), non_ASCII_controls_characters = [128, 159, 1757, 1757, 1807, 1807, 6158, 6158, 8204, 8204, 8205, 8205, 8232, 8232, 8233, 8233, 8288, 8288, 8289, 8289, 8290, 8290, 8291, 8291, 8298, 8303, 65279, 65279, 65529, 65532, 119155, 119162], non_character_codepoints = [64976, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1114110, 1114111], prohibited_characters = [0, 31, 127, 127, 832, 832, 833, 833, 8206, 8206, 8207, 8207, 8234, 8234, 8235, 8235, 8236, 8236, 8237, 8237, 8238, 8238, 8298, 8298, 8299, 8299, 8300, 8300, 8301, 8301, 8302, 8302, 8303, 8303, 12272, 12283, 55296, 57343, 57344, 63743, 65529, 65529, 65530, 65530, 65531, 65531, 65532, 65532, 65533, 65533, 917505, 917505, 917536, 917631, 983040, 1048573, 1048576, 1114109], isProhibitedCharacter = t => inRange(t, non_ASCII_space_characters) || inRange(t, prohibited_characters) || inRange(t, non_ASCII_controls_characters) || inRange(t, non_character_codepoints), bidirectional_r_al = [1470, 1470, 1472, 1472, 1475, 1475, 1488, 1514, 1520, 1524, 1563, 1563, 1567, 1567, 1569, 1594, 1600, 1610, 1645, 1647, 1649, 1749, 1757, 1757, 1765, 1766, 1786, 1790, 1792, 1805, 1808, 1808, 1810, 1836, 1920, 1957, 1969, 1969, 8207, 8207, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65020, 65136, 65140, 65142, 65276], isBidirectionalRAL = t => inRange(t, bidirectional_r_al), bidirectional_l = [65, 90, 97, 122, 170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 544, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 1013, 1024, 1154, 1162, 1230, 1232, 1269, 1272, 1273, 1280, 1295, 1329, 1366, 1369, 1375, 1377, 1415, 1417, 1417, 2307, 2307, 2309, 2361, 2365, 2368, 2377, 2380, 2384, 2384, 2392, 2401, 2404, 2416, 2434, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2494, 2496, 2503, 2504, 2507, 2508, 2519, 2519, 2524, 2525, 2527, 2529, 2534, 2545, 2548, 2554, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2622, 2624, 2649, 2652, 2654, 2654, 2662, 2671, 2674, 2676, 2691, 2691, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2752, 2761, 2761, 2763, 2764, 2768, 2768, 2784, 2784, 2790, 2799, 2818, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2878, 2880, 2880, 2887, 2888, 2891, 2892, 2903, 2903, 2908, 2909, 2911, 2913, 2918, 2928, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3006, 3007, 3009, 3010, 3014, 3016, 3018, 3020, 3031, 3031, 3047, 3058, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3137, 3140, 3168, 3169, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3262, 3262, 3264, 3268, 3271, 3272, 3274, 3275, 3285, 3286, 3294, 3294, 3296, 3297, 3302, 3311, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3390, 3392, 3398, 3400, 3402, 3404, 3415, 3415, 3424, 3425, 3430, 3439, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3535, 3537, 3544, 3551, 3570, 3572, 3585, 3632, 3634, 3635, 3648, 3654, 3663, 3675, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3792, 3801, 3804, 3805, 3840, 3863, 3866, 3892, 3894, 3894, 3896, 3896, 3902, 3911, 3913, 3946, 3967, 3967, 3973, 3973, 3976, 3979, 4030, 4037, 4039, 4044, 4047, 4047, 4096, 4129, 4131, 4135, 4137, 4138, 4140, 4140, 4145, 4145, 4152, 4152, 4160, 4183, 4256, 4293, 4304, 4344, 4347, 4347, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 4961, 4988, 5024, 5108, 5121, 5750, 5761, 5786, 5792, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5941, 5942, 5952, 5969, 5984, 5996, 5998, 6e3, 6016, 6070, 6078, 6085, 6087, 6088, 6100, 6106, 6108, 6108, 6112, 6121, 6160, 6169, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8206, 8206, 8305, 8305, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8509, 8511, 8517, 8521, 8544, 8579, 9014, 9082, 9109, 9109, 9372, 9449, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12588, 12593, 12686, 12688, 12727, 12784, 12828, 12832, 12867, 12896, 12923, 12927, 12976, 12992, 13003, 13008, 13054, 13056, 13174, 13179, 13277, 13280, 13310, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 55296, 64045, 64048, 64106, 64256, 64262, 64275, 64279, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 66304, 66334, 66336, 66339, 66352, 66378, 66560, 66597, 66600, 66637, 118784, 119029, 119040, 119078, 119082, 119142, 119146, 119154, 119171, 119172, 119180, 119209, 119214, 119261, 119808, 119892, 119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995, 119997, 12e4, 120002, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144, 120146, 120483, 120488, 120777, 131072, 173782, 194560, 195101, 983040, 1048573, 1048576, 1114109], isBidirectionalL = t => inRange(t, bidirectional_l), mapping2space = isNonASCIISpaceCharacter, mapping2nothing = isCommonlyMappedToNothing, getCodePoint = t => t.codePointAt(0), first = t => t[0], last = t => t[t.length - 1]; function toCodePoints(t) { const e = [], i = t.length; for (let n = 0; n < i; n += 1) { const r = t.charCodeAt(n); if (r >= 55296 && r <= 56319 && i > n + 1) { const i = t.charCodeAt(n + 1); if (i >= 56320 && i <= 57343) { e.push(1024 * (r - 55296) + i - 56320 + 65536), n += 1; continue } } e.push(r) } return e } function saslprep(t, e = {}) { if ("string" != typeof t) throw new TypeError("Expected string."); if (0 === t.length) return ""; const i = toCodePoints(t).map((t => mapping2space(t) ? 32 : t)).filter((t => !mapping2nothing(t))), n = String.fromCodePoint.apply(null, i).normalize("NFKC"), r = toCodePoints(n); if (r.some(isProhibitedCharacter)) throw new Error("Prohibited character, see https://tools.ietf.org/html/rfc4013#section-2.3"); if (!0 !== e.allowUnassigned) { if (r.some(isUnassignedCodePoint)) throw new Error("Unassigned code point, see https://tools.ietf.org/html/rfc4013#section-2.5") } const s = r.some(isBidirectionalRAL), o = r.some(isBidirectionalL); if (s && o) throw new Error("String must not contain RandALCat and LCat at the same time, see https://tools.ietf.org/html/rfc3454#section-6"); const a = isBidirectionalRAL(getCodePoint(n[0])); const h = isBidirectionalRAL(getCodePoint(last(n))); if (s && (!a || !h)) throw new Error("Bidirectional RandALCat character must be the first and the last character of the string, see https://tools.ietf.org/html/rfc3454#section-6"); return n } class PDFSecurity { static generateFileID(t = {}) { let e = `${t.CreationDate.getTime()}\n`; for (let i in t) t.hasOwnProperty(i) && (e += `${i}: ${t[i].valueOf()}\n`); return wordArrayToBuffer(CryptoJS.MD5(e)) } static generateRandomWordArray(t) { return CryptoJS.lib.WordArray.random(t) } static create(t, e = {}) { return e.ownerPassword || e.userPassword ? new PDFSecurity(t, e) : null } constructor(t, e = {}) { if (!e.ownerPassword && !e.userPassword) throw new Error("None of owner password and user password is defined."); this.document = t, this._setupEncryption(e) } _setupEncryption(t) { switch (t.pdfVersion) { case "1.4": case "1.5": this.version = 2; break; case "1.6": case "1.7": this.version = 4; break; case "1.7ext3": this.version = 5; break; default: this.version = 1 }const e = { Filter: "Standard" }; switch (this.version) { case 1: case 2: case 4: this._setupEncryptionV1V2V4(this.version, e, t); break; case 5: this._setupEncryptionV5(e, t) }this.dictionary = this.document.ref(e) } _setupEncryptionV1V2V4(t, e, i) { let n, r; switch (t) { case 1: n = 2, this.keyBits = 40, r = getPermissionsR2(i.permissions); break; case 2: n = 3, this.keyBits = 128, r = getPermissionsR3(i.permissions); break; case 4: n = 4, this.keyBits = 128, r = getPermissionsR3(i.permissions) }const s = processPasswordR2R3R4(i.userPassword), o = i.ownerPassword ? processPasswordR2R3R4(i.ownerPassword) : s, a = getOwnerPasswordR2R3R4(n, this.keyBits, s, o); let h; this.encryptionKey = getEncryptionKeyR2R3R4(n, this.keyBits, this.document._id, s, a, r), h = 2 === n ? getUserPasswordR2(this.encryptionKey) : getUserPasswordR3R4(this.document._id, this.encryptionKey), e.V = t, t >= 2 && (e.Length = this.keyBits), 4 === t && (e.CF = { StdCF: { AuthEvent: "DocOpen", CFM: "AESV2", Length: this.keyBits / 8 } }, e.StmF = "StdCF", e.StrF = "StdCF"), e.R = n, e.O = wordArrayToBuffer(a), e.U = wordArrayToBuffer(h), e.P = r } _setupEncryptionV5(t, e) { this.keyBits = 256; const i = getPermissionsR3(e.permissions), n = processPasswordR5(e.userPassword), r = e.ownerPassword ? processPasswordR5(e.ownerPassword) : n; this.encryptionKey = getEncryptionKeyR5(PDFSecurity.generateRandomWordArray); const s = getUserPasswordR5(n, PDFSecurity.generateRandomWordArray), o = getUserEncryptionKeyR5(n, CryptoJS.lib.WordArray.create(s.words.slice(10, 12), 8), this.encryptionKey), a = getOwnerPasswordR5(r, s, PDFSecurity.generateRandomWordArray), h = getOwnerEncryptionKeyR5(r, CryptoJS.lib.WordArray.create(a.words.slice(10, 12), 8), s, this.encryptionKey), c = getEncryptedPermissionsR5(i, this.encryptionKey, PDFSecurity.generateRandomWordArray); t.V = 5, t.Length = this.keyBits, t.CF = { StdCF: { AuthEvent: "DocOpen", CFM: "AESV3", Length: this.keyBits / 8 } }, t.StmF = "StdCF", t.StrF = "StdCF", t.R = 5, t.O = wordArrayToBuffer(a), t.OE = wordArrayToBuffer(h), t.U = wordArrayToBuffer(s), t.UE = wordArrayToBuffer(o), t.P = i, t.Perms = wordArrayToBuffer(c) } getEncryptFn(t, e) { let i, n; if (this.version < 5 && (i = this.encryptionKey.clone().concat(CryptoJS.lib.WordArray.create([(255 & t) << 24 | (65280 & t) << 8 | t >> 8 & 65280 | 255 & e, (65280 & e) << 16], 5))), 1 === this.version || 2 === this.version) { let t = CryptoJS.MD5(i); return t.sigBytes = Math.min(16, this.keyBits / 8 + 5), e => wordArrayToBuffer(CryptoJS.RC4.encrypt(CryptoJS.lib.WordArray.create(e), t).ciphertext) } n = 4 === this.version ? CryptoJS.MD5(i.concat(CryptoJS.lib.WordArray.create([1933667412], 4))) : this.encryptionKey; const r = PDFSecurity.generateRandomWordArray(16), s = { mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7, iv: r }; return t => wordArrayToBuffer(r.clone().concat(CryptoJS.AES.encrypt(CryptoJS.lib.WordArray.create(t), n, s).ciphertext)) } end() { this.dictionary.end() } } function getPermissionsR2(t = {}) { let e = -64; return t.printing && (e |= 4), t.modifying && (e |= 8), t.copying && (e |= 16), t.annotating && (e |= 32), e } function getPermissionsR3(t = {}) { let e = -3904; return "lowResolution" === t.printing && (e |= 4), "highResolution" === t.printing && (e |= 2052), t.modifying && (e |= 8), t.copying && (e |= 16), t.annotating && (e |= 32), t.fillingForms && (e |= 256), t.contentAccessibility && (e |= 512), t.documentAssembly && (e |= 1024), e } function getUserPasswordR2(t) { return CryptoJS.RC4.encrypt(processPasswordR2R3R4(), t).ciphertext } function getUserPasswordR3R4(t, e) { const i = e.clone(); let n = CryptoJS.MD5(processPasswordR2R3R4().concat(CryptoJS.lib.WordArray.create(t))); for (let t = 0; t < 20; t++) { const r = Math.ceil(i.sigBytes / 4); for (let n = 0; n < r; n++)i.words[n] = e.words[n] ^ (t | t << 8 | t << 16 | t << 24); n = CryptoJS.RC4.encrypt(n, i).ciphertext } return n.concat(CryptoJS.lib.WordArray.create(null, 16)) } function getOwnerPasswordR2R3R4(t, e, i, n) { let r = n, s = t >= 3 ? 51 : 1; for (let t = 0; t < s; t++)r = CryptoJS.MD5(r); const o = r.clone(); o.sigBytes = e / 8; let a = i; s = t >= 3 ? 20 : 1; for (let t = 0; t < s; t++) { const e = Math.ceil(o.sigBytes / 4); for (let i = 0; i < e; i++)o.words[i] = r.words[i] ^ (t | t << 8 | t << 16 | t << 24); a = CryptoJS.RC4.encrypt(a, o).ciphertext } return a } function getEncryptionKeyR2R3R4(t, e, i, n, r, s) { let o = n.clone().concat(r).concat(CryptoJS.lib.WordArray.create([lsbFirstWord(s)], 4)).concat(CryptoJS.lib.WordArray.create(i)); const a = t >= 3 ? 51 : 1; for (let t = 0; t < a; t++)o = CryptoJS.MD5(o), o.sigBytes = e / 8; return o } function getUserPasswordR5(t, e) { const i = e(8), n = e(8); return CryptoJS.SHA256(t.clone().concat(i)).concat(i).concat(n) } function getUserEncryptionKeyR5(t, e, i) { const n = CryptoJS.SHA256(t.clone().concat(e)), r = { mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.NoPadding, iv: CryptoJS.lib.WordArray.create(null, 16) }; return CryptoJS.AES.encrypt(i, n, r).ciphertext } function getOwnerPasswordR5(t, e, i) { const n = i(8), r = i(8); return CryptoJS.SHA256(t.clone().concat(n).concat(e)).concat(n).concat(r) } function getOwnerEncryptionKeyR5(t, e, i, n) { const r = CryptoJS.SHA256(t.clone().concat(e).concat(i)), s = { mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.NoPadding, iv: CryptoJS.lib.WordArray.create(null, 16) }; return CryptoJS.AES.encrypt(n, r, s).ciphertext } function getEncryptionKeyR5(t) { return t(32) } function getEncryptedPermissionsR5(t, e, i) { const n = CryptoJS.lib.WordArray.create([lsbFirstWord(t), 4294967295, 1415668834], 12).concat(i(4)), r = { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding }; return CryptoJS.AES.encrypt(n, e, r).ciphertext } function processPasswordR2R3R4(t = "") { const e = Buffer.alloc(32), i = t.length; let n = 0; for (; n < i && n < 32;) { const i = t.charCodeAt(n); if (i > 255) throw new Error("Password contains one or more invalid characters."); e[n] = i, n++ } for (; n < 32;)e[n] = PASSWORD_PADDING[n - i], n++; return CryptoJS.lib.WordArray.create(e) } function processPasswordR5(t = "") { t = unescape(encodeURIComponent(saslprep(t))); const e = Math.min(127, t.length), i = Buffer.alloc(e); for (let n = 0; n < e; n++)i[n] = t.charCodeAt(n); return CryptoJS.lib.WordArray.create(i) } function lsbFirstWord(t) { return (255 & t) << 24 | (65280 & t) << 8 | t >> 8 & 65280 | t >> 24 & 255 } function wordArrayToBuffer(t) { const e = []; for (let i = 0; i < t.sigBytes; i++)e.push(t.words[Math.floor(i / 4)] >> 8 * (3 - i % 4) & 255); return Buffer.from(e) } const PASSWORD_PADDING = [40, 191, 78, 94, 78, 117, 138, 65, 100, 0, 78, 86, 255, 250, 1, 8, 46, 46, 0, 182, 208, 104, 62, 128, 47, 12, 169, 254, 100, 83, 105, 122], { number: number } = PDFObject; class PDFGradient { constructor(t) { this.doc = t, this.stops = [], this.embedded = !1, this.transform = [1, 0, 0, 1, 0, 0] } stop(t, e, i) { if (null == i && (i = 1), e = this.doc._normalizeColor(e), 0 === this.stops.length) if (3 === e.length) this._colorSpace = "DeviceRGB"; else if (4 === e.length) this._colorSpace = "DeviceCMYK"; else { if (1 !== e.length) throw new Error("Unknown color space"); this._colorSpace = "DeviceGray" } else if ("DeviceRGB" === this._colorSpace && 3 !== e.length || "DeviceCMYK" === this._colorSpace && 4 !== e.length || "DeviceGray" === this._colorSpace && 1 !== e.length) throw new Error("All gradient stops must use the same color space"); return i = Math.max(0, Math.min(1, i)), this.stops.push([t, e, i]), this } setTransform(t, e, i, n, r, s) { return this.transform = [t, e, i, n, r, s], this } embed(t) { let e; const i = this.stops.length; if (0 === i) return; this.embedded = !0, this.matrix = t; const n = this.stops[i - 1]; n[0] < 1 && this.stops.push([1, n[1], n[2]]); const r = [], s = [], o = []; for (let t = 0; t < i - 1; t++)s.push(0, 1), t + 2 !== i && r.push(this.stops[t + 1][0]), e = this.doc.ref({ FunctionType: 2, Domain: [0, 1], C0: this.stops[t + 0][1], C1: this.stops[t + 1][1], N: 1 }), o.push(e), e.end(); 1 === i ? e = o[0] : (e = this.doc.ref({ FunctionType: 3, Domain: [0, 1], Functions: o, Bounds: r, Encode: s }), e.end()), this.id = "Sh" + ++this.doc._gradCount; const a = this.shader(e); a.end(); const h = this.doc.ref({ Type: "Pattern", PatternType: 2, Shading: a, Matrix: this.matrix.map(number) }); if (h.end(), this.stops.some((t => t[2] < 1))) { let t = this.opacityGradient(); t._colorSpace = "DeviceGray"; for (let e of this.stops) t.stop(e[0], [e[2]]); t = t.embed(this.matrix); const e = [0, 0, this.doc.page.width, this.doc.page.height], i = this.doc.ref({ Type: "XObject", Subtype: "Form", FormType: 1, BBox: e, Group: { Type: "Group", S: "Transparency", CS: "DeviceGray" }, Resources: { ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"], Pattern: { Sh1: t } } }); i.write("/Pattern cs /Sh1 scn"), i.end(`${e.join(" ")} re f`); const n = this.doc.ref({ Type: "ExtGState", SMask: { Type: "Mask", S: "Luminosity", G: i } }); n.end(); const r = this.doc.ref({ Type: "Pattern", PatternType: 1, PaintType: 1, TilingType: 2, BBox: e, XStep: e[2], YStep: e[3], Resources: { ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"], Pattern: { Sh1: h }, ExtGState: { Gs1: n } } }); r.write("/Gs1 gs /Pattern cs /Sh1 scn"), r.end(`${e.join(" ")} re f`), this.doc.page.patterns[this.id] = r } else this.doc.page.patterns[this.id] = h; return h } apply(t) { const [e, i, n, r, s, o] = this.doc._ctm, [a, h, c, l, d, u] = this.transform, f = [e * a + n * h, i * a + r * h, e * c + n * l, i * c + r * l, e * d + n * u + s, i * d + r * u + o]; this.embedded && f.join(" ") === this.matrix.join(" ") || this.embed(f), this.doc._setColorSpace("Pattern", t); const p = t ? "SCN" : "scn"; return this.doc.addContent(`/${this.id} ${p}`) } } class PDFLinearGradient extends PDFGradient { constructor(t, e, i, n, r) { super(t), this.x1 = e, this.y1 = i, this.x2 = n, this.y2 = r } shader(t) { return this.doc.ref({ ShadingType: 2, ColorSpace: this._colorSpace, Coords: [this.x1, this.y1, this.x2, this.y2], Function: t, Extend: [!0, !0] }) } opacityGradient() { return new PDFLinearGradient(this.doc, this.x1, this.y1, this.x2, this.y2) } } class PDFRadialGradient extends PDFGradient { constructor(t, e, i, n, r, s, o) { super(t), this.doc = t, this.x1 = e, this.y1 = i, this.r1 = n, this.x2 = r, this.y2 = s, this.r2 = o } shader(t) { return this.doc.ref({ ShadingType: 3, ColorSpace: this._colorSpace, Coords: [this.x1, this.y1, this.r1, this.x2, this.y2, this.r2], Function: t, Extend: [!0, !0] }) } opacityGradient() { return new PDFRadialGradient(this.doc, this.x1, this.y1, this.r1, this.x2, this.y2, this.r2) } } var Gradient = { PDFGradient: PDFGradient, PDFLinearGradient: PDFLinearGradient, PDFRadialGradient: PDFRadialGradient }; const underlyingColorSpaces = ["DeviceCMYK", "DeviceRGB"]; class PDFTilingPattern { constructor(t, e, i, n, r) { this.doc = t, this.bBox = e, this.xStep = i, this.yStep = n, this.stream = r } createPattern() { const t = this.doc.ref(); t.end(); const [e, i, n, r, s, o] = this.doc._ctm, [a, h, c, l, d, u] = [1, 0, 0, 1, 0, 0], f = [e * a + n * h, i * a + r * h, e * c + n * l, i * c + r * l, e * d + n * u + s, i * d + r * u + o], p = this.doc.ref({ Type: "Pattern", PatternType: 1, PaintType: 2, TilingType: 2, BBox: this.bBox, XStep: this.xStep, YStep: this.yStep, Matrix: f.map((t => +t.toFixed(5))), Resources: t }); return p.end(this.stream), p } embedPatternColorSpaces() { underlyingColorSpaces.forEach((t => { const e = this.getPatternColorSpaceId(t); if (this.doc.page.colorSpaces[e]) return; const i = this.doc.ref(["Pattern", t]); i.end(), this.doc.page.colorSpaces[e] = i })) } getPatternColorSpaceId(t) { return `CsP${t}` } embed() { this.id || (this.doc._patternCount = this.doc._patternCount + 1, this.id = "P" + this.doc._patternCount, this.pattern = this.createPattern()), this.doc.page.patterns[this.id] || (this.doc.page.patterns[this.id] = this.pattern) } apply(t, e) { this.embedPatternColorSpaces(), this.embed(); const i = this.doc._normalizeColor(e); if (!i) throw Error(`invalid pattern color. (value: ${e})`); const n = this.getPatternColorSpaceId(this.doc._getColorSpace(i)); this.doc._setColorSpace(n, t); const r = t ? "SCN" : "scn"; return this.doc.addContent(`${i.join(" ")} /${this.id} ${r}`) } } var pattern = { PDFTilingPattern: PDFTilingPattern }; const { PDFGradient: PDFGradient$1, PDFLinearGradient: PDFLinearGradient$1, PDFRadialGradient: PDFRadialGradient$1 } = Gradient, { PDFTilingPattern: PDFTilingPattern$1 } = pattern; var ColorMixin = { initColor() { return this._opacityRegistry = {}, this._opacityCount = 0, this._patternCount = 0, this._gradCount = 0 }, _normalizeColor(t) { if ("string" == typeof t) if ("#" === t.charAt(0)) { 4 === t.length && (t = t.replace(/#([0-9A-F])([0-9A-F])([0-9A-F])/i, "#$1$1$2$2$3$3")); const e = parseInt(t.slice(1), 16); t = [e >> 16, e >> 8 & 255, 255 & e] } else namedColors[t] && (t = namedColors[t]); return Array.isArray(t) ? (3 === t.length ? t = t.map((t => t / 255)) : 4 === t.length && (t = t.map((t => t / 100))), t) : null }, _setColor(t, e) { return t instanceof PDFGradient$1 ? (t.apply(e), !0) : Array.isArray(t) && t[0] instanceof PDFTilingPattern$1 ? (t[0].apply(e, t[1]), !0) : this._setColorCore(t, e) }, _setColorCore(t, e) { if (!(t = this._normalizeColor(t))) return !1; const i = e ? "SCN" : "scn", n = this._getColorSpace(t); return this._setColorSpace(n, e), t = t.join(" "), this.addContent(`${t} ${i}`), !0 }, _setColorSpace(t, e) { const i = e ? "CS" : "cs"; return this.addContent(`/${t} ${i}`) }, _getColorSpace: t => 4 === t.length ? "DeviceCMYK" : "DeviceRGB", fillColor(t, e) { return this._setColor(t, !1) && this.fillOpacity(e), this._fillColor = [t, e], this }, strokeColor(t, e) { return this._setColor(t, !0) && this.strokeOpacity(e), this }, opacity(t) { return this._doOpacity(t, t), this }, fillOpacity(t) { return this._doOpacity(t, null), this }, strokeOpacity(t) { return this._doOpacity(null, t), this }, _doOpacity(t, e) { let i, n; if (null == t && null == e) return; null != t && (t = Math.max(0, Math.min(1, t))), null != e && (e = Math.max(0, Math.min(1, e))); const r = `${t}_${e}`; if (this._opacityRegistry[r]) [i, n] = this._opacityRegistry[r]; else { i = { Type: "ExtGState" }, null != t && (i.ca = t), null != e && (i.CA = e), i = this.ref(i), i.end(); n = `Gs${++this._opacityCount}`, this._opacityRegistry[r] = [i, n] } return this.page.ext_gstates[n] = i, this.addContent(`/${n} gs`) }, linearGradient(t, e, i, n) { return new PDFLinearGradient$1(this, t, e, i, n) }, radialGradient(t, e, i, n, r, s) { return new PDFRadialGradient$1(this, t, e, i, n, r, s) }, pattern(t, e, i, n) { return new PDFTilingPattern$1(this, t, e, i, n) } }, namedColors = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], grey: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }; let cx, cy, px, py, sx, sy; cx = cy = px = py = sx = sy = 0; const parameters = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 }, parse = function (t) { let e; const i = []; let n = [], r = "", s = !1, o = 0; for (let a of t) if (null != parameters[a]) o = parameters[a], e && (r.length > 0 && (n[n.length] = +r), i[i.length] = { cmd: e, args: n }, n = [], r = "", s = !1), e = a; else if ([" ", ","].includes(a) || "-" === a && r.length > 0 && "e" !== r[r.length - 1] || "." === a && s) { if (0 === r.length) continue; n.length === o ? (i[i.length] = { cmd: e, args: n }, n = [+r], "M" === e && (e = "L"), "m" === e && (e = "l")) : n[n.length] = +r, s = "." === a, r = ["-", "."].includes(a) ? a : "" } else r += a, "." === a && (s = !0); return r.length > 0 && (n.length === o ? (i[i.length] = { cmd: e, args: n }, n = [+r], "M" === e && (e = "L"), "m" === e && (e = "l")) : n[n.length] = +r), i[i.length] = { cmd: e, args: n }, i }, apply = function (t, e) { cx = cy = px = py = sx = sy = 0; for (let i = 0; i < t.length; i++) { const n = t[i]; "function" == typeof runners[n.cmd] && runners[n.cmd](e, n.args) } }, runners = { M: (t, e) => (cx = e[0], cy = e[1], px = py = null, sx = cx, sy = cy, t.moveTo(cx, cy)), m: (t, e) => (cx += e[0], cy += e[1], px = py = null, sx = cx, sy = cy, t.moveTo(cx, cy)), C: (t, e) => (cx = e[4], cy = e[5], px = e[2], py = e[3], t.bezierCurveTo(...e)), c: (t, e) => (t.bezierCurveTo(e[0] + cx, e[1] + cy, e[2] + cx, e[3] + cy, e[4] + cx, e[5] + cy), px = cx + e[2], py = cy + e[3], cx += e[4], cy += e[5]), S: (t, e) => (null === px && (px = cx, py = cy), t.bezierCurveTo(cx - (px - cx), cy - (py - cy), e[0], e[1], e[2], e[3]), px = e[0], py = e[1], cx = e[2], cy = e[3]), s: (t, e) => (null === px && (px = cx, py = cy), t.bezierCurveTo(cx - (px - cx), cy - (py - cy), cx + e[0], cy + e[1], cx + e[2], cy + e[3]), px = cx + e[0], py = cy + e[1], cx += e[2], cy += e[3]), Q: (t, e) => (px = e[0], py = e[1], cx = e[2], cy = e[3], t.quadraticCurveTo(e[0], e[1], cx, cy)), q: (t, e) => (t.quadraticCurveTo(e[0] + cx, e[1] + cy, e[2] + cx, e[3] + cy), px = cx + e[0], py = cy + e[1], cx += e[2], cy += e[3]), T: (t, e) => (null === px ? (px = cx, py = cy) : (px = cx - (px - cx), py = cy - (py - cy)), t.quadraticCurveTo(px, py, e[0], e[1]), px = cx - (px - cx), py = cy - (py - cy), cx = e[0], cy = e[1]), t: (t, e) => (null === px ? (px = cx, py = cy) : (px = cx - (px - cx), py = cy - (py - cy)), t.quadraticCurveTo(px, py, cx + e[0], cy + e[1]), cx += e[0], cy += e[1]), A: (t, e) => (solveArc(t, cx, cy, e), cx = e[5], cy = e[6]), a: (t, e) => (e[5] += cx, e[6] += cy, solveArc(t, cx, cy, e), cx = e[5], cy = e[6]), L: (t, e) => (cx = e[0], cy = e[1], px = py = null, t.lineTo(cx, cy)), l: (t, e) => (cx += e[0], cy += e[1], px = py = null, t.lineTo(cx, cy)), H: (t, e) => (cx = e[0], px = py = null, t.lineTo(cx, cy)), h: (t, e) => (cx += e[0], px = py = null, t.lineTo(cx, cy)), V: (t, e) => (cy = e[0], px = py = null, t.lineTo(cx, cy)), v: (t, e) => (cy += e[0], px = py = null, t.lineTo(cx, cy)), Z: t => (t.closePath(), cx = sx, cy = sy), z: t => (t.closePath(), cx = sx, cy = sy) }, solveArc = function (t, e, i, n) { const [r, s, o, a, h, c, l] = n, d = arcToSegments(c, l, r, s, a, h, o, e, i); for (let e of d) { const i = segmentToBezier(...e); t.bezierCurveTo(...i) } }, arcToSegments = function (t, e, i, n, r, s, o, a, h) { const c = o * (Math.PI / 180), l = Math.sin(c), d = Math.cos(c); i = Math.abs(i), n = Math.abs(n), px = d * (a - t) * .5 + l * (h - e) * .5, py = d * (h - e) * .5 - l * (a - t) * .5; let u = px * px / (i * i) + py * py / (n * n); u > 1 && (u = Math.sqrt(u), i *= u, n *= u); const f = d / i, p = l / i, g = -l / n, m = d / n, y = f * a + p * h, b = g * a + m * h, S = f * t + p * e, _ = g * t + m * e; let C = 1 / ((S - y) * (S - y) + (_ - b) * (_ - b)) - .25; C < 0 && (C = 0); let w = Math.sqrt(C); s === r && (w = -w); const P = .5 * (y + S) - w * (_ - b), x = .5 * (b + _) + w * (S - y), F = Math.atan2(b - x, y - P); let A = Math.atan2(_ - x, S - P) - F; A < 0 && 1 === s ? A += 2 * Math.PI : A > 0 && 0 === s && (A -= 2 * Math.PI); const D = Math.ceil(Math.abs(A / (.5 * Math.PI + .001))), T = []; for (let t = 0; t < D; t++) { const e = F + t * A / D, r = F + (t + 1) * A / D; T[t] = [P, x, e, r, i, n, l, d] } return T }, segmentToBezier = function (t, e, i, n, r, s, o, a) { const h = a * r, c = -o * s, l = o * r, d = a * s, u = .5 * (n - i), f = 8 / 3 * Math.sin(.5 * u) * Math.sin(.5 * u) / Math.sin(u), p = t + Math.cos(i) - f * Math.sin(i), g = e + Math.sin(i) + f * Math.cos(i), m = t + Math.cos(n), y = e + Math.sin(n), b = m + f * Math.sin(n), S = y - f * Math.cos(n); return [h * p + c * g, l * p + d * g, h * b + c * S, l * b + d * S, h * m + c * y, l * m + d * y] }; class SVGPath { static apply(t, e) { const i = parse(e); apply(i, t) } } const { number: number$1 } = PDFObject, KAPPA = (Math.sqrt(2) - 1) / 3 * 4; var VectorMixin = { initVector() { return this._ctm = [1, 0, 0, 1, 0, 0], this._ctmStack = [] }, save() { return this._ctmStack.push(this._ctm.slice()), this.addContent("q") }, restore() { return this._ctm = this._ctmStack.pop() || [1, 0, 0, 1, 0, 0], this.addContent("Q") }, closePath() { return this.addContent("h") }, lineWidth(t) { return this.addContent(`${number$1(t)} w`) }, _CAP_STYLES: { BUTT: 0, ROUND: 1, SQUARE: 2 }, lineCap(t) { return "string" == typeof t && (t = this._CAP_STYLES[t.toUpperCase()]), this.addContent(`${t} J`) }, _JOIN_STYLES: { MITER: 0, ROUND: 1, BEVEL: 2 }, lineJoin(t) { return "string" == typeof t && (t = this._JOIN_STYLES[t.toUpperCase()]), this.addContent(`${t} j`) }, miterLimit(t) { return this.addContent(`${number$1(t)} M`) }, dash(t, e = {}) { const i = t; Array.isArray(t) || (t = [t, e.space || t]); if (!t.every((t => Number.isFinite(t) && t > 0))) throw new Error(`dash(${JSON.stringify(i)}, ${JSON.stringify(e)}) invalid, lengths must be numeric and greater than zero`); return t = t.map(number$1).join(" "), this.addContent(`[${t}] ${number$1(e.phase || 0)} d`) }, undash() { return this.addContent("[] 0 d") }, moveTo(t, e) { return this.addContent(`${number$1(t)} ${number$1(e)} m`) }, lineTo(t, e) { return this.addContent(`${number$1(t)} ${number$1(e)} l`) }, bezierCurveTo(t, e, i, n, r, s) { return this.addContent(`${number$1(t)} ${number$1(e)} ${number$1(i)} ${number$1(n)} ${number$1(r)} ${number$1(s)} c`) }, quadraticCurveTo(t, e, i, n) { return this.addContent(`${number$1(t)} ${number$1(e)} ${number$1(i)} ${number$1(n)} v`) }, rect(t, e, i, n) { return this.addContent(`${number$1(t)} ${number$1(e)} ${number$1(i)} ${number$1(n)} re`) }, roundedRect(t, e, i, n, r) { null == r && (r = 0); const s = (r = Math.min(r, .5 * i, .5 * n)) * (1 - KAPPA); return this.moveTo(t + r, e), this.lineTo(t + i - r, e), this.bezierCurveTo(t + i - s, e, t + i, e + s, t + i, e + r), this.lineTo(t + i, e + n - r), this.bezierCurveTo(t + i, e + n - s, t + i - s, e + n, t + i - r, e + n), this.lineTo(t + r, e + n), this.bezierCurveTo(t + s, e + n, t, e + n - s, t, e + n - r), this.lineTo(t, e + r), this.bezierCurveTo(t, e + s, t + s, e, t + r, e), this.closePath() }, ellipse(t, e, i, n) { null == n && (n = i); const r = i * KAPPA, s = n * KAPPA, o = (t -= i) + 2 * i, a = (e -= n) + 2 * n, h = t + i, c = e + n; return this.moveTo(t, c), this.bezierCurveTo(t, c - s, h - r, e, h, e), this.bezierCurveTo(h + r, e, o, c - s, o, c), this.bezierCurveTo(o, c + s, h + r, a, h, a), this.bezierCurveTo(h - r, a, t, c + s, t, c), this.closePath() }, circle(t, e, i) { return this.ellipse(t, e, i) }, arc(t, e, i, n, r, s) { null == s && (s = !1); const o = 2 * Math.PI, a = .5 * Math.PI; let h = r - n; if (Math.abs(h) > o) h = o; else if (0 !== h && s !== h < 0) { h = (s ? -1 : 1) * o + h } const c = Math.ceil(Math.abs(h) / a), l = h / c, d = l / a * KAPPA * i; let u = n, f = -Math.sin(u) * d, p = Math.cos(u) * d, g = t + Math.cos(u) * i, m = e + Math.sin(u) * i; this.moveTo(g, m); for (let n = 0; n < c; n++) { const n = g + f, r = m + p; u += l, g = t + Math.cos(u) * i, m = e + Math.sin(u) * i, f = -Math.sin(u) * d, p = Math.cos(u) * d; const s = g - f, o = m - p; this.bezierCurveTo(n, r, s, o, g, m) } return this }, polygon(...t) { this.moveTo(...t.shift() || []); for (let e of t) this.lineTo(...e || []); return this.closePath() }, path(t) { return SVGPath.apply(this, t), this }, _windingRule: t => /even-?odd/.test(t) ? "*" : "", fill(t, e) { return /(even-?odd)|(non-?zero)/.test(t) && (e = t, t = null), t && this.fillColor(t), this.addContent(`f${this._windingRule(e)}`) }, stroke(t) { return t && this.strokeColor(t), this.addContent("S") }, fillAndStroke(t, e, i) { null == e && (e = t); const n = /(even-?odd)|(non-?zero)/; return n.test(t) && (i = t, t = null), n.test(e) && (i = e, e = t), t && (this.fillColor(t), this.strokeColor(e)), this.addContent(`B${this._windingRule(i)}`) }, clip(t) { return this.addContent(`W${this._windingRule(t)} n`) }, transform(t, e, i, n, r, s) { const o = this._ctm, [a, h, c, l, d, u] = o; o[0] = a * t + c * e, o[1] = h * t + l * e, o[2] = a * i + c * n, o[3] = h * i + l * n, o[4] = a * r + c * s + d, o[5] = h * r + l * s + u; const f = [t, e, i, n, r, s].map((t => number$1(t))).join(" "); return this.addContent(`${f} cm`) }, translate(t, e) { return this.transform(1, 0, 0, 1, t, e) }, rotate(t, e = {}) { let i; const n = t * Math.PI / 180, r = Math.cos(n), s = Math.sin(n); let o = i = 0; if (null != e.origin) { [o, i] = e.origin; const t = o * s + i * r; o -= o * r - i * s, i -= t } return this.transform(r, s, -s, r, o, i) }, scale(t, e, i = {}) { let n; null == e && (e = t), "object" == typeof e && (i = e, e = t); let r = n = 0; return null != i.origin && ([r, n] = i.origin, r -= t * r, n -= e * n), this.transform(t, 0, 0, e, r, n) } }; const WIN_ANSI_MAP = { 402: 131, 8211: 150, 8212: 151, 8216: 145, 8217: 146, 8218: 130, 8220: 147, 8221: 148, 8222: 132, 8224: 134, 8225: 135, 8226: 149, 8230: 133, 8364: 128, 8240: 137, 8249: 139, 8250: 155, 710: 136, 8482: 153, 338: 140, 339: 156, 732: 152, 352: 138, 353: 154, 376: 159, 381: 142, 382: 158 }, characters = ".notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n  \nspace         exclam         quotedbl       numbersign\ndollar        percent        ampersand      quotesingle\nparenleft     parenright     asterisk       plus\ncomma         hyphen         period         slash\nzero          one            two            three\nfour          five           six            seven\neight         nine           colon          semicolon\nless          equal          greater        question\n  \nat            A              B              C\nD             E              F              G\nH             I              J              K\nL             M              N              O\nP             Q              R              S\nT             U              V              W\nX             Y              Z              bracketleft\nbackslash     bracketright   asciicircum    underscore\n  \ngrave         a              b              c\nd             e              f              g\nh             i              j              k\nl             m              n              o\np             q              r              s\nt             u              v              w\nx             y              z              braceleft\nbar           braceright     asciitilde     .notdef\n  \nEuro          .notdef        quotesinglbase florin\nquotedblbase  ellipsis       dagger         daggerdbl\ncircumflex    perthousand    Scaron         guilsinglleft\nOE            .notdef        Zcaron         .notdef\n.notdef       quoteleft      quoteright     quotedblleft\nquotedblright bullet         endash         emdash\ntilde         trademark      scaron         guilsinglright\noe            .notdef        zcaron         ydieresis\n  \nspace         exclamdown     cent           sterling\ncurrency      yen            brokenbar      section\ndieresis      copyright      ordfeminine    guillemotleft\nlogicalnot    hyphen         registered     macron\ndegree        plusminus      twosuperior    threesuperior\nacute         mu             paragraph      periodcentered\ncedilla       onesuperior    ordmasculine   guillemotright\nonequarter    onehalf        threequarters  questiondown\n  \nAgrave        Aacute         Acircumflex    Atilde\nAdieresis     Aring          AE             Ccedilla\nEgrave        Eacute         Ecircumflex    Edieresis\nIgrave        Iacute         Icircumflex    Idieresis\nEth           Ntilde         Ograve         Oacute\nOcircumflex   Otilde         Odieresis      multiply\nOslash        Ugrave         Uacute         Ucircumflex\nUdieresis     Yacute         Thorn          germandbls\n  \nagrave        aacute         acircumflex    atilde\nadieresis     aring          ae             ccedilla\negrave        eacute         ecircumflex    edieresis\nigrave        iacute         icircumflex    idieresis\neth           ntilde         ograve         oacute\nocircumflex   otilde         odieresis      divide\noslash        ugrave         uacute         ucircumflex\nudieresis     yacute         thorn          ydieresis".split(/\s+/); class AFMFont { static open(t) { return new AFMFont(fs.readFileSync(t, "utf8")) } constructor(t) { this.contents = t, this.attributes = {}, this.glyphWidths = {}, this.boundingBoxes = {}, this.kernPairs = {}, this.parse(), this.charWidths = new Array(256); for (let t = 0; t <= 255; t++)this.charWidths[t] = this.glyphWidths[characters[t]]; this.bbox = this.attributes.FontBBox.split(/\s+/).map((t => +t)), this.ascender = +(this.attributes.Ascender || 0), this.descender = +(this.attributes.Descender || 0), this.xHeight = +(this.attributes.XHeight || 0), this.capHeight = +(this.attributes.CapHeight || 0), this.lineGap = this.bbox[3] - this.bbox[1] - (this.ascender - this.descender) } parse() { let t = ""; for (let o of this.contents.split("\n")) { var e, i; if (e = o.match(/^Start(\w+)/)) t = e[1]; else if (e = o.match(/^End(\w+)/)) t = ""; else switch (t) { case "FontMetrics": var n = (e = o.match(/(^\w+)\s+(.*)/))[1], r = e[2]; (i = this.attributes[n]) ? (Array.isArray(i) || (i = this.attributes[n] = [i]), i.push(r)) : this.attributes[n] = r; break; case "CharMetrics": if (!/^CH?\s/.test(o)) continue; var s = o.match(/\bN\s+(\.?\w+)\s*;/)[1]; this.glyphWidths[s] = +o.match(/\bWX\s+(\d+)\s*;/)[1]; break; case "KernPairs": (e = o.match(/^KPX\s+(\.?\w+)\s+(\.?\w+)\s+(-?\d+)/)) && (this.kernPairs[e[1] + "\0" + e[2]] = parseInt(e[3])) } } } encodeText(t) { const e = []; for (let i = 0, n = t.length; i < n; i++) { let n = t.charCodeAt(i); n = WIN_ANSI_MAP[n] || n, e.push(n.toString(16)) } return e } glyphsForString(t) { const e = []; for (let i = 0, n = t.length; i < n; i++) { const n = t.charCodeAt(i); e.push(this.characterToGlyph(n)) } return e } characterToGlyph(t) { return characters[WIN_ANSI_MAP[t] || t] || ".notdef" } widthOfGlyph(t) { return this.glyphWidths[t] || 0 } getKernPair(t, e) { return this.kernPairs[t + "\0" + e] || 0 } advancesForGlyphs(t) { const e = []; for (let i = 0; i < t.length; i++) { const n = t[i], r = t[i + 1]; e.push(this.widthOfGlyph(n) + this.getKernPair(n, r)) } return e } } class PDFFont { constructor() { } encode() { throw new Error("Must be implemented by subclasses") } widthOfString() { throw new Error("Must be implemented by subclasses") } ref() { return null != this.dictionary ? this.dictionary : this.dictionary = this.document.ref() } finalize() { if (!this.embedded && null != this.dictionary) return this.embed(), this.embedded = !0 } embed() { throw new Error("Must be implemented by subclasses") } lineHeight(t, e) { null == e && (e = !1); const i = e ? this.lineGap : 0; return (this.ascender + i - this.descender) / 1e3 * t } } const STANDARD_FONTS = { Courier: () => fs.readFileSync(__dirname + "/data/Courier.afm", "utf8"), "Courier-Bold": () => fs.readFileSync(__dirname + "/data/Courier-Bold.afm", "utf8"), "Courier-Oblique": () => fs.readFileSync(__dirname + "/data/Courier-Oblique.afm", "utf8"), "Courier-BoldOblique": () => fs.readFileSync(__dirname + "/data/Courier-BoldOblique.afm", "utf8"), Helvetica: () => fs.readFileSync(__dirname + "/data/Helvetica.afm", "utf8"), "Helvetica-Bold": () => fs.readFileSync(__dirname + "/data/Helvetica-Bold.afm", "utf8"), "Helvetica-Oblique": () => fs.readFileSync(__dirname + "/data/Helvetica-Oblique.afm", "utf8"), "Helvetica-BoldOblique": () => fs.readFileSync(__dirname + "/data/Helvetica-BoldOblique.afm", "utf8"), "Times-Roman": () => fs.readFileSync(__dirname + "/data/Times-Roman.afm", "utf8"), "Times-Bold": () => fs.readFileSync(__dirname + "/data/Times-Bold.afm", "utf8"), "Times-Italic": () => fs.readFileSync(__dirname + "/data/Times-Italic.afm", "utf8"), "Times-BoldItalic": () => fs.readFileSync(__dirname + "/data/Times-BoldItalic.afm", "utf8"), Symbol: () => fs.readFileSync(__dirname + "/data/Symbol.afm", "utf8"), ZapfDingbats: () => fs.readFileSync(__dirname + "/data/ZapfDingbats.afm", "utf8") }; class StandardFont extends PDFFont { constructor(t, e, i) { super(), this.document = t, this.name = e, this.id = i, this.font = new AFMFont(STANDARD_FONTS[this.name]()), ({ ascender: this.ascender, descender: this.descender, bbox: this.bbox, lineGap: this.lineGap, xHeight: this.xHeight, capHeight: this.capHeight } = this.font) } embed() { return this.dictionary.data = { Type: "Font", BaseFont: this.name, Subtype: "Type1", Encoding: "WinAnsiEncoding" }, this.dictionary.end() } encode(t) { const e = this.font.encodeText(t), i = this.font.glyphsForString(`${t}`), n = this.font.advancesForGlyphs(i), r = []; for (let t = 0; t < i.length; t++) { const e = i[t]; r.push({ xAdvance: n[t], yAdvance: 0, xOffset: 0, yOffset: 0, advanceWidth: this.font.widthOfGlyph(e) }) } return [e, r] } widthOfString(t, e) { const i = this.font.glyphsForString(`${t}`), n = this.font.advancesForGlyphs(i); let r = 0; for (let t of n) r += t; return r * (e / 1e3) } static isStandardFont(t) { return t in STANDARD_FONTS } } const toHex = function (t) { return `0000${t.toString(16)}`.slice(-4) }; class EmbeddedFont extends PDFFont { constructor(t, e, i) { super(), this.document = t, this.font = e, this.id = i, this.subset = this.font.createSubset(), this.unicode = [[0]], this.widths = [this.font.getGlyph(0).advanceWidth], this.name = this.font.postscriptName, this.scale = 1e3 / this.font.unitsPerEm, this.ascender = this.font.ascent * this.scale, this.descender = this.font.descent * this.scale, this.xHeight = this.font.xHeight * this.scale, this.capHeight = this.font.capHeight * this.scale, this.lineGap = this.font.lineGap * this.scale, this.bbox = this.font.bbox, !1 !== t.options.fontLayoutCache && (this.layoutCache = Object.create(null)) } layoutRun(t, e) { const i = this.font.layout(t, e); for (let t = 0; t < i.positions.length; t++) { const e = i.positions[t]; for (let t in e) e[t] *= this.scale; e.advanceWidth = i.glyphs[t].advanceWidth * this.scale } return i } layoutCached(t) { if (!this.layoutCache) return this.layoutRun(t); let e; if (e = this.layoutCache[t]) return e; const i = this.layoutRun(t); return this.layoutCache[t] = i, i } layout(t, e, i) { if (e) return this.layoutRun(t, e); let n = i ? null : [], r = i ? null : [], s = 0, o = 0, a = 0; for (; a <= t.length;) { var h; if (a === t.length && o < a || (h = t.charAt(a), [" ", "\t"].includes(h))) { const e = this.layoutCached(t.slice(o, ++a)); i || (n = n.concat(e.glyphs), r = r.concat(e.positions)), s += e.advanceWidth, o = a } else a++ } return { glyphs: n, positions: r, advanceWidth: s } } encode(t, e) { const { glyphs: i, positions: n } = this.layout(t, e), r = []; for (let t = 0; t < i.length; t++) { const e = i[t], n = this.subset.includeGlyph(e.id); r.push(`0000${n.toString(16)}`.slice(-4)), null == this.widths[n] && (this.widths[n] = e.advanceWidth * this.scale), null == this.unicode[n] && (this.unicode[n] = e.codePoints) } return [r, n] } widthOfString(t, e, i) { return this.layout(t, i, !0).advanceWidth * (e / 1e3) } embed() { const t = null != this.subset.cff, e = this.document.ref(); t && (e.data.Subtype = "CIDFontType0C"), this.subset.encodeStream().on("data", (t => e.write(t))).on("end", (() => e.end())); const i = ((null != this.font["OS/2"] ? this.font["OS/2"].sFamilyClass : void 0) || 0) >> 8; let n = 0; this.font.post.isFixedPitch && (n |= 1), 1 <= i && i <= 7 && (n |= 2), n |= 4, 10 === i && (n |= 8), this.font.head.macStyle.italic && (n |= 64); const r = [1, 2, 3, 4, 5, 6].map((t => String.fromCharCode((this.id.charCodeAt(t) || 73) + 17))).join("") + "+" + this.font.postscriptName, { bbox: s } = this.font, o = this.document.ref({ Type: "FontDescriptor", FontName: r, Flags: n, FontBBox: [s.minX * this.scale, s.minY * this.scale, s.maxX * this.scale, s.maxY * this.scale], ItalicAngle: this.font.italicAngle, Ascent: this.ascender, Descent: this.descender, CapHeight: (this.font.capHeight || this.font.ascent) * this.scale, XHeight: (this.font.xHeight || 0) * this.scale, StemV: 0 }); t ? o.data.FontFile3 = e : o.data.FontFile2 = e, o.end(); const a = { Type: "Font", Subtype: "CIDFontType0", BaseFont: r, CIDSystemInfo: { Registry: new String("Adobe"), Ordering: new String("Identity"), Supplement: 0 }, FontDescriptor: o, W: [0, this.widths] }; t || (a.Subtype = "CIDFontType2", a.CIDToGIDMap = "Identity"); const h = this.document.ref(a); return h.end(), this.dictionary.data = { Type: "Font", Subtype: "Type0", BaseFont: r, Encoding: "Identity-H", DescendantFonts: [h], ToUnicode: this.toUnicodeCmap() }, this.dictionary.end() } toUnicodeCmap() { const t = this.document.ref(), e = []; for (let t of this.unicode) { const i = []; for (let e of t) e > 65535 && (e -= 65536, i.push(toHex(e >>> 10 & 1023 | 55296)), e = 56320 | 1023 & e), i.push(toHex(e)); e.push(`<${i.join(" ")}>`) } return t.end(`/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange\n1 beginbfrange\n<0000> <${toHex(e.length - 1)}> [${e.join(" ")}]\nendbfrange\nendcmap\nCMapName currentdict /CMap defineresource pop\nend\nend`), t } } class PDFFontFactory { static open(t, e, i, n) { let r; if ("string" == typeof e) { if (StandardFont.isStandardFont(e)) return new StandardFont(t, e, n); e = fs.readFileSync(e) } if (Buffer.isBuffer(e) ? r = fontkit.create(e, i) : e instanceof Uint8Array ? r = fontkit.create(Buffer.from(e), i) : e instanceof ArrayBuffer && (r = fontkit.create(Buffer.from(new Uint8Array(e)), i)), null == r) throw new Error("Not a supported font format or standard PDF font."); return new EmbeddedFont(t, r, n) } } var FontsMixin = { initFonts(t = "Helvetica") { this._fontFamilies = {}, this._fontCount = 0, this._fontSize = 12, this._font = null, this._registeredFonts = {}, t && this.font(t) }, font(t, e, i) { let n, r; if ("number" == typeof e && (i = e, e = null), "string" == typeof t && this._registeredFonts[t] ? (n = t, ({ src: t, family: e } = this._registeredFonts[t])) : (n = e || t, "string" != typeof n && (n = null)), null != i && this.fontSize(i), r = this._fontFamilies[n]) return this._font = r, this; const s = "F" + ++this._fontCount; return this._font = PDFFontFactory.open(this, t, e, s), (r = this._fontFamilies[this._font.name]) ? (this._font = r, this) : (n && (this._fontFamilies[n] = this._font), this._font.name && (this._fontFamilies[this._font.name] = this._font), this) }, fontSize(t) { return this._fontSize = t, this }, currentLineHeight(t) { return null == t && (t = !1), this._font.lineHeight(this._fontSize, t) }, registerFont(t, e, i) { return this._registeredFonts[t] = { src: e, family: i }, this } }; class LineWrapper extends events.EventEmitter { constructor(t, e) { super(), this.document = t, this.indent = e.indent || 0, this.characterSpacing = e.characterSpacing || 0, this.wordSpacing = 0 === e.wordSpacing, this.columns = e.columns || 1, this.columnGap = null != e.columnGap ? e.columnGap : 18, this.lineWidth = (e.width - this.columnGap * (this.columns - 1)) / this.columns, this.spaceLeft = this.lineWidth, this.startX = this.document.x, this.startY = this.document.y, this.column = 1, this.ellipsis = e.ellipsis, this.continuedX = 0, this.features = e.features, null != e.height ? (this.height = e.height, this.maxY = this.startY + e.height) : this.maxY = this.document.page.maxY(), this.on("firstLine", (t => { const e = this.continuedX || this.indent; return this.document.x += e, this.lineWidth -= e, this.once("line", (() => { if (this.document.x -= e, this.lineWidth += e, t.continued && !this.continuedX && (this.continuedX = this.indent), !t.continued) return this.continuedX = 0 })) })), this.on("lastLine", (t => { const { align: e } = t; return "justify" === e && (t.align = "left"), this.lastLine = !0, this.once("line", (() => (this.document.y += t.paragraphGap || 0, t.align = e, this.lastLine = !1))) })) } wordWidth(t) { return this.document.widthOfString(t, this) + this.characterSpacing + this.wordSpacing } eachWord(t, e) { let i; const n = new LineBreaker(t); let r = null; const s = Object.create(null); for (; i = n.nextBreak();) { var o; let n = t.slice((null != r ? r.position : void 0) || 0, i.position), c = null != s[n] ? s[n] : s[n] = this.wordWidth(n); if (c > this.lineWidth + this.continuedX) { let t = r; const s = {}; for (; n.length;) { var a, h; c > this.spaceLeft ? (a = Math.ceil(this.spaceLeft / (c / n.length)), c = this.wordWidth(n.slice(0, a)), h = c <= this.spaceLeft && a < n.length) : a = n.length; let r = c > this.spaceLeft && a > 0; for (; r || h;)r ? (c = this.wordWidth(n.slice(0, --a)), r = c > this.spaceLeft && a > 0) : (c = this.wordWidth(n.slice(0, ++a)), r = c > this.spaceLeft && a > 0, h = c <= this.spaceLeft && a < n.length); if (0 === a && this.spaceLeft === this.lineWidth && (a = 1), s.required = i.required || a < n.length, o = e(n.slice(0, a), c, s, t), t = { required: !1 }, n = n.slice(a), c = this.wordWidth(n), !1 === o) break } } else o = e(n, c, i, r); if (!1 === o) break; r = i } } wrap(t, e) { null != e.indent && (this.indent = e.indent), null != e.characterSpacing && (this.characterSpacing = e.characterSpacing), null != e.wordSpacing && (this.wordSpacing = e.wordSpacing), null != e.ellipsis && (this.ellipsis = e.ellipsis); const i = this.document.y + this.document.currentLineHeight(!0); (this.document.y > this.maxY || i > this.maxY) && this.nextSection(); let n = "", r = 0, s = 0, o = 0, { y: a } = this.document; const h = () => (e.textWidth = r + this.wordSpacing * (s - 1), e.wordCount = s, e.lineWidth = this.lineWidth, ({ y: a } = this.document), this.emit("line", n, e, this), o++); return this.emit("sectionStart", e, this), this.eachWord(t, ((t, i, o, a) => { if ((null == a || a.required) && (this.emit("firstLine", e, this), this.spaceLeft = this.lineWidth), i <= this.spaceLeft && (n += t, r += i, s++), o.required || i > this.spaceLeft) { const a = this.document.currentLineHeight(!0); if (null != this.height && this.ellipsis && this.document.y + 2 * a > this.maxY && this.column >= this.columns) { for (!0 === this.ellipsis && (this.ellipsis = ""), n = n.replace(/\s+$/, ""), r = this.wordWidth(n + this.ellipsis); n && r > this.lineWidth;)n = n.slice(0, -1).replace(/\s+$/, ""), r = this.wordWidth(n + this.ellipsis); r <= this.lineWidth && (n += this.ellipsis), r = this.wordWidth(n) } if (o.required && (i > this.spaceLeft && (h(), n = t, r = i, s = 1), this.emit("lastLine", e, this)), h(), this.document.y + a > this.maxY) { if (!this.nextSection()) return s = 0, n = "", !1 } return o.required ? (this.spaceLeft = this.lineWidth, n = "", r = 0, s = 0) : (this.spaceLeft = this.lineWidth - i, n = t, r = i, s = 1) } return this.spaceLeft -= i })), s > 0 && (this.emit("lastLine", e, this), h()), this.emit("sectionEnd", e, this), !0 === e.continued ? (o > 1 && (this.continuedX = 0), this.continuedX += e.textWidth || 0, this.document.y = a) : this.document.x = this.startX } nextSection(t) { if (this.emit("sectionEnd", t, this), ++this.column > this.columns) { if (null != this.height) return !1; this.document.continueOnNewPage(), this.column = 1, this.startY = this.document.page.margins.top, this.maxY = this.document.page.maxY(), this.document.x = this.startX, this.document._fillColor && this.document.fillColor(...this.document._fillColor), this.emit("pageBreak", t, this) } else this.document.x += this.lineWidth + this.columnGap, this.document.y = this.startY, this.emit("columnBreak", t, this); return this.emit("sectionStart", t, this), !0 } } const { number: number$2 } = PDFObject; var TextMixin = { initText() { return this._line = this._line.bind(this), this.x = 0, this.y = 0, this._lineGap = 0 }, lineGap(t) { return this._lineGap = t, this }, moveDown(t) { return null == t && (t = 1), this.y += this.currentLineHeight(!0) * t + this._lineGap, this }, moveUp(t) { return null == t && (t = 1), this.y -= this.currentLineHeight(!0) * t + this._lineGap, this }, _text(t, e, i, n, r) { t = null == t ? "" : `${t}`, (n = this._initOptions(e, i, n)).wordSpacing && (t = t.replace(/\s{2,}/g, " ")); const s = () => { n.structParent && n.structParent.add(this.struct(n.structType || "P", [this.markStructureContent(n.structType || "P")])) }; if (n.width) { let e = this._wrapper; e || (e = new LineWrapper(this, n), e.on("line", r), e.on("firstLine", s)), this._wrapper = n.continued ? e : null, this._textOptions = n.continued ? n : null, e.wrap(t, n) } else for (let e of t.split("\n")) s(), r(e, n); return this }, text(t, e, i, n) { return this._text(t, e, i, n, this._line) }, widthOfString(t, e = {}) { return this._font.widthOfString(t, this._fontSize, e.features) + (e.characterSpacing || 0) * (t.length - 1) }, heightOfString(t, e) { const { x: i, y: n } = this; (e = this._initOptions(e)).height = 1 / 0; const r = e.lineGap || this._lineGap || 0; this._text(t, this.x, this.y, e, (() => this.y += this.currentLineHeight(!0) + r)); const s = this.y - n; return this.x = i, this.y = n, s }, list(t, e, i, n, r) { const s = (n = this._initOptions(e, i, n)).listType || "bullet", o = Math.round(this._font.ascender / 1e3 * this._fontSize), a = o / 2, h = n.bulletRadius || o / 3, c = n.textIndent || ("bullet" === s ? 5 * h : 2 * o), l = n.bulletIndent || ("bullet" === s ? 8 * h : 2 * o); let d = 1; const u = [], f = [], p = []; var g = function (t) { let e = 1; for (let i = 0; i < t.length; i++) { const n = t[i]; Array.isArray(n) ? (d++, g(n), d--) : (u.push(n), f.push(d), "bullet" !== s && p.push(e++)) } }; g(t); (r = new LineWrapper(this, n)).on("line", this._line), d = 1; let m = 0; return r.on("firstLine", (() => { let t, e, i, o, u; if (n.structParent && (n.structTypes ? [e, i, o] = n.structTypes : [e, i, o] = ["LI", "Lbl", "LBody"]), e ? (t = this.struct(e), n.structParent.add(t)) : n.structParent && (t = n.structParent), (u = f[m++]) !== d) { const t = l * (u - d); this.x += t, r.lineWidth -= t, d = u } switch (t && (i || o) && t.add(this.struct(i || o, [this.markStructureContent(i || o)])), s) { case "bullet": this.circle(this.x - c + h, this.y + a, h), this.fill(); break; case "numbered": case "lettered": var g = function (t) { switch (s) { case "numbered": return `${t}.`; case "lettered": var e = String.fromCharCode((t - 1) % 26 + 65), i = Math.floor((t - 1) / 26 + 1); return `${Array(i + 1).join(e)}.` } }(p[m - 1]); this._fragment(g, this.x - c, this.y, n) }t && i && o && t.add(this.struct(o, [this.markStructureContent(o)])), t && t !== n.structParent && t.end() })), r.on("sectionStart", (() => { const t = c + l * (d - 1); return this.x += t, r.lineWidth -= t })), r.on("sectionEnd", (() => { const t = c + l * (d - 1); return this.x -= t, r.lineWidth += t })), r.wrap(u.join("\n"), n), this }, _initOptions(t = {}, e, i = {}) { "object" == typeof t && (i = t, t = null); const n = Object.assign({}, i); if (this._textOptions) for (let t in this._textOptions) { const e = this._textOptions[t]; "continued" !== t && void 0 === n[t] && (n[t] = e) } return null != t && (this.x = t), null != e && (this.y = e), !1 !== n.lineBreak && (null == n.width && (n.width = this.page.width - this.x - this.page.margins.right), n.width = Math.max(n.width, 0)), n.columns || (n.columns = 0), null == n.columnGap && (n.columnGap = 18), n }, _line(t, e = {}, i) { this._fragment(t, this.x, this.y, e); const n = e.lineGap || this._lineGap || 0; return i ? this.y += this.currentLineHeight(!0) + n : this.x += this.widthOfString(t) }, _fragment(t, e, i, n) { let r, s, o, a, h, c; if (0 === (t = `${t}`.replace(/\n/g, "")).length) return; const l = n.align || "left"; let d = n.wordSpacing || 0; const u = n.characterSpacing || 0; if (n.width) switch (l) { case "right": h = this.widthOfString(t.replace(/\s+$/, ""), n), e += n.lineWidth - h; break; case "center": e += n.lineWidth / 2 - n.textWidth / 2; break; case "justify": c = t.trim().split(/\s+/), h = this.widthOfString(t.replace(/\s+/g, ""), n); var f = this.widthOfString(" ") + u; d = Math.max(0, (n.lineWidth - h) / Math.max(1, c.length - 1) - f) }if ("number" == typeof n.baseline) r = -n.baseline; else { switch (n.baseline) { case "svg-middle": r = .5 * this._font.xHeight; break; case "middle": case "svg-central": r = .5 * (this._font.descender + this._font.ascender); break; case "bottom": case "ideographic": r = this._font.descender; break; case "alphabetic": r = 0; break; case "mathematical": r = .5 * this._font.ascender; break; case "hanging": r = .8 * this._font.ascender; break; case "top": r = this._font.ascender; break; default: r = this._font.ascender }r = r / 1e3 * this._fontSize } const p = n.textWidth + d * (n.wordCount - 1) + u * (t.length - 1); if (null != n.link && this.link(e, i, p, this.currentLineHeight(), n.link), null != n.goTo && this.goTo(e, i, p, this.currentLineHeight(), n.goTo), null != n.destination && this.addNamedDestination(n.destination, "XYZ", e, i, null), n.underline) { this.save(), n.stroke || this.strokeColor(...this._fillColor || []); const t = this._fontSize < 10 ? .5 : Math.floor(this._fontSize / 10); this.lineWidth(t); let r = i + this.currentLineHeight() - t; this.moveTo(e, r), this.lineTo(e + p, r), this.stroke(), this.restore() } if (n.strike) { this.save(), n.stroke || this.strokeColor(...this._fillColor || []); const t = this._fontSize < 10 ? .5 : Math.floor(this._fontSize / 10); this.lineWidth(t); let r = i + this.currentLineHeight() / 2; this.moveTo(e, r), this.lineTo(e + p, r), this.stroke(), this.restore() } if (this.save(), n.oblique) { let t; t = "number" == typeof n.oblique ? -Math.tan(n.oblique * Math.PI / 180) : -.25, this.transform(1, 0, 0, 1, e, i), this.transform(1, 0, t, 1, -t * r, 0), this.transform(1, 0, 0, 1, -e, -i) } this.transform(1, 0, 0, -1, 0, this.page.height), i = this.page.height - i - r, null == this.page.fonts[this._font.id] && (this.page.fonts[this._font.id] = this._font.ref()), this.addContent("BT"), this.addContent(`1 0 0 1 ${number$2(e)} ${number$2(i)} Tm`), this.addContent(`/${this._font.id} ${number$2(this._fontSize)} Tf`); const g = n.fill && n.stroke ? 2 : n.stroke ? 1 : 0; if (g && this.addContent(`${g} Tr`), u && this.addContent(`${number$2(u)} Tc`), d) { c = t.trim().split(/\s+/), d += this.widthOfString(" ") + u, d *= 1e3 / this._fontSize, s = [], a = []; for (let t of c) { const [e, i] = this._font.encode(t, n.features); s = s.concat(e), a = a.concat(i); const r = {}, o = a[a.length - 1]; for (let t in o) { const e = o[t]; r[t] = e } r.xAdvance += d, a[a.length - 1] = r } } else[s, a] = this._font.encode(t, n.features); const m = this._fontSize / 1e3, y = []; let b = 0, S = !1; const _ = t => { if (b < t) { const e = s.slice(b, t).join(""), i = a[t - 1].xAdvance - a[t - 1].advanceWidth; y.push(`<${e}> ${number$2(-i)}`) } return b = t }, C = t => { if (_(t), y.length > 0) return this.addContent(`[${y.join(" ")}] TJ`), y.length = 0 }; for (o = 0; o < a.length; o++) { const t = a[o]; t.xOffset || t.yOffset ? (C(o), this.addContent(`1 0 0 1 ${number$2(e + t.xOffset * m)} ${number$2(i + t.yOffset * m)} Tm`), C(o + 1), S = !0) : (S && (this.addContent(`1 0 0 1 ${number$2(e)} ${number$2(i)} Tm`), S = !1), t.xAdvance - t.advanceWidth != 0 && _(o + 1)), e += t.xAdvance * m } return C(o), this.addContent("ET"), this.restore() } }; const MARKERS = [65472, 65473, 65474, 65475, 65477, 65478, 65479, 65480, 65481, 65482, 65483, 65484, 65485, 65486, 65487], COLOR_SPACE_MAP = { 1: "DeviceGray", 3: "DeviceRGB", 4: "DeviceCMYK" }; class JPEG { constructor(t, e) { let i; if (this.data = t, this.label = e, 65496 !== this.data.readUInt16BE(0)) throw "SOI not found in JPEG"; let n = 2; for (; n < this.data.length && (i = this.data.readUInt16BE(n), n += 2, !MARKERS.includes(i));)n += this.data.readUInt16BE(n); if (!MARKERS.includes(i)) throw "Invalid JPEG."; n += 2, this.bits = this.data[n++], this.height = this.data.readUInt16BE(n), n += 2, this.width = this.data.readUInt16BE(n), n += 2; const r = this.data[n++]; this.colorSpace = COLOR_SPACE_MAP[r], this.obj = null } embed(t) { if (!this.obj) return this.obj = t.ref({ Type: "XObject", Subtype: "Image", BitsPerComponent: this.bits, Width: this.width, Height: this.height, ColorSpace: this.colorSpace, Filter: "DCTDecode" }), "DeviceCMYK" === this.colorSpace && (this.obj.data.Decode = [1, 0, 1, 0, 1, 0, 1, 0]), this.obj.end(this.data), this.data = null } } class PNGImage { constructor(t, e) { this.label = e, this.image = new PNG(t), this.width = this.image.width, this.height = this.image.height, this.imgData = this.image.imgData, this.obj = null } embed(t) { let e = !1; if (this.document = t, this.obj) return; const i = this.image.hasAlphaChannel, n = 1 === this.image.interlaceMethod; if (this.obj = this.document.ref({ Type: "XObject", Subtype: "Image", BitsPerComponent: i ? 8 : this.image.bits, Width: this.width, Height: this.height, Filter: "FlateDecode" }), !i) { const t = this.document.ref({ Predictor: n ? 1 : 15, Colors: this.image.colors, BitsPerComponent: this.image.bits, Columns: this.width }); this.obj.data.DecodeParms = t, t.end() } if (0 === this.image.palette.length) this.obj.data.ColorSpace = this.image.colorSpace; else { const t = this.document.ref(); t.end(Buffer.from(this.image.palette)), this.obj.data.ColorSpace = ["Indexed", "DeviceRGB", this.image.palette.length / 3 - 1, t] } if (null != this.image.transparency.grayscale) { const t = this.image.transparency.grayscale; this.obj.data.Mask = [t, t] } else if (this.image.transparency.rgb) { const { rgb: t } = this.image.transparency, e = []; for (let i of t) e.push(i, i); this.obj.data.Mask = e } else { if (this.image.transparency.indexed) return e = !0, this.loadIndexedAlphaChannel(); if (i) return e = !0, this.splitAlphaChannel() } if (n && !e) return this.decodeData(); this.finalize() } finalize() { if (this.alphaChannel) { const t = this.document.ref({ Type: "XObject", Subtype: "Image", Height: this.height, Width: this.width, BitsPerComponent: 8, Filter: "FlateDecode", ColorSpace: "DeviceGray", Decode: [0, 1] }); t.end(this.alphaChannel), this.obj.data.SMask = t } return this.obj.end(this.imgData), this.image = null, this.imgData = null } splitAlphaChannel() { return this.image.decodePixels((t => { let e, i; const n = this.image.colors, r = this.width * this.height, s = Buffer.alloc(r * n), o = Buffer.alloc(r); let a = i = e = 0; const h = t.length, c = 16 === this.image.bits ? 1 : 0; for (; a < h;) { for (let e = 0; e < n; e++)s[i++] = t[a++], a += c; o[e++] = t[a++], a += c } return this.imgData = zlib.deflateSync(s), this.alphaChannel = zlib.deflateSync(o), this.finalize() })) } loadIndexedAlphaChannel() { const t = this.image.transparency.indexed; return this.image.decodePixels((e => { const i = Buffer.alloc(this.width * this.height); let n = 0; for (let r = 0, s = e.length; r < s; r++)i[n++] = t[e[r]]; return this.alphaChannel = zlib.deflateSync(i), this.finalize() })) } decodeData() { this.image.decodePixels((t => { this.imgData = zlib.deflateSync(t), this.finalize() })) } } class PDFImage { static open(t, e) { let i; if (Buffer.isBuffer(t)) i = t; else if (t instanceof ArrayBuffer) i = Buffer.from(new Uint8Array(t)); else { let e; if (e = /^data:.+;base64,(.*)$/.exec(t)) i = Buffer.from(e[1], "base64"); else if (i = fs.readFileSync(t), !i) return } if (255 === i[0] && 216 === i[1]) return new JPEG(i, e); if (137 === i[0] && "PNG" === i.toString("ascii", 1, 4)) return new PNGImage(i, e); throw new Error("Unknown image format.") } } var ImagesMixin = { initImages() { return this._imageRegistry = {}, this._imageCount = 0 }, image(t, e, i, n = {}) { let r, s, o, a, h, c, l; "object" == typeof e && (n = e, e = null), e = null != (c = null != e ? e : n.x) ? c : this.x, i = null != (l = null != i ? i : n.y) ? l : this.y, "string" == typeof t && (a = this._imageRegistry[t]), a || (a = t.width && t.height ? t : this.openImage(t)), a.obj || a.embed(this), null == this.page.xobjects[a.label] && (this.page.xobjects[a.label] = a.obj); let d = n.width || a.width, u = n.height || a.height; if (n.width && !n.height) { const t = d / a.width; d = a.width * t, u = a.height * t } else if (n.height && !n.width) { const t = u / a.height; d = a.width * t, u = a.height * t } else n.scale ? (d = a.width * n.scale, u = a.height * n.scale) : n.fit ? ([o, r] = n.fit, s = o / r, h = a.width / a.height, h > s ? (d = o, u = o / h) : (u = r, d = r * h)) : n.cover && ([o, r] = n.cover, s = o / r, h = a.width / a.height, h > s ? (u = r, d = r * h) : (d = o, u = o / h)); return (n.fit || n.cover) && ("center" === n.align ? e = e + o / 2 - d / 2 : "right" === n.align && (e = e + o - d), "center" === n.valign ? i = i + r / 2 - u / 2 : "bottom" === n.valign && (i = i + r - u)), null != n.link && this.link(e, i, d, u, n.link), null != n.goTo && this.goTo(e, i, d, u, n.goTo), null != n.destination && this.addNamedDestination(n.destination, "XYZ", e, i, null), this.y === i && (this.y += u), this.save(), this.transform(d, 0, 0, -u, e, i + u), this.addContent(`/${a.label} Do`), this.restore(), this }, openImage(t) { let e; return "string" == typeof t && (e = this._imageRegistry[t]), e || (e = PDFImage.open(t, "I" + ++this._imageCount), "string" == typeof t && (this._imageRegistry[t] = e)), e } }, AnnotationsMixin = { annotate(t, e, i, n, r) { r.Type = "Annot", r.Rect = this._convertRect(t, e, i, n), r.Border = [0, 0, 0], "Link" === r.Subtype && void 0 === r.F && (r.F = 4), "Link" !== r.Subtype && null == r.C && (r.C = this._normalizeColor(r.color || [0, 0, 0])), delete r.color, "string" == typeof r.Dest && (r.Dest = new String(r.Dest)); for (let t in r) { const e = r[t]; r[t[0].toUpperCase() + t.slice(1)] = e } const s = this.ref(r); return this.page.annotations.push(s), s.end(), this }, note(t, e, i, n, r, s = {}) { return s.Subtype = "Text", s.Contents = new String(r), s.Name = "Comment", null == s.color && (s.color = [243, 223, 92]), this.annotate(t, e, i, n, s) }, goTo(t, e, i, n, r, s = {}) { return s.Subtype = "Link", s.A = this.ref({ S: "GoTo", D: new String(r) }), s.A.end(), this.annotate(t, e, i, n, s) }, link(t, e, i, n, r, s = {}) { if (s.Subtype = "Link", "number" == typeof r) { const t = this._root.data.Pages.data; if (!(r >= 0 && r < t.Kids.length)) throw new Error(`The document has no page ${r}`); s.A = this.ref({ S: "GoTo", D: [t.Kids[r], "XYZ", null, null, null] }), s.A.end() } else s.A = this.ref({ S: "URI", URI: new String(r) }), s.A.end(); return this.annotate(t, e, i, n, s) }, _markup(t, e, i, n, r = {}) { const [s, o, a, h] = this._convertRect(t, e, i, n); return r.QuadPoints = [s, h, a, h, s, o, a, o], r.Contents = new String, this.annotate(t, e, i, n, r) }, highlight(t, e, i, n, r = {}) { return r.Subtype = "Highlight", null == r.color && (r.color = [241, 238, 148]), this._markup(t, e, i, n, r) }, underline(t, e, i, n, r = {}) { return r.Subtype = "Underline", this._markup(t, e, i, n, r) }, strike(t, e, i, n, r = {}) { return r.Subtype = "StrikeOut", this._markup(t, e, i, n, r) }, lineAnnotation(t, e, i, n, r = {}) { return r.Subtype = "Line", r.Contents = new String, r.L = [t, this.page.height - e, i, this.page.height - n], this.annotate(t, e, i, n, r) }, rectAnnotation(t, e, i, n, r = {}) { return r.Subtype = "Square", r.Contents = new String, this.annotate(t, e, i, n, r) }, ellipseAnnotation(t, e, i, n, r = {}) { return r.Subtype = "Circle", r.Contents = new String, this.annotate(t, e, i, n, r) }, textAnnotation(t, e, i, n, r, s = {}) { return s.Subtype = "FreeText", s.Contents = new String(r), s.DA = new String, this.annotate(t, e, i, n, s) }, fileAnnotation(t, e, i, n, r = {}, s = {}) { const o = this.file(r.src, Object.assign({ hidden: !0 }, r)); return s.Subtype = "FileAttachment", s.FS = o, s.Contents ? s.Contents = new String(s.Contents) : o.data.Desc && (s.Contents = o.data.Desc), this.annotate(t, e, i, n, s) }, _convertRect(t, e, i, n) { let r = e; e += n; let s = t + i; const [o, a, h, c, l, d] = this._ctm; return s = o * s + h * r + l, r = a * s + c * r + d, [t = o * t + h * e + l, e = a * t + c * e + d, s, r] } }; class PDFOutline { constructor(t, e, i, n, r = { expanded: !1 }) { this.document = t, this.options = r, this.outlineData = {}, null !== n && (this.outlineData.Dest = [n.dictionary, "Fit"]), null !== e && (this.outlineData.Parent = e), null !== i && (this.outlineData.Title = new String(i)), this.dictionary = this.document.ref(this.outlineData), this.children = [] } addItem(t, e = { expanded: !1 }) { const i = new PDFOutline(this.document, this.dictionary, t, this.document.page, e); return this.children.push(i), i } endOutline() { if (this.children.length > 0) { this.options.expanded && (this.outlineData.Count = this.children.length); const t = this.children[0], e = this.children[this.children.length - 1]; this.outlineData.First = t.dictionary, this.outlineData.Last = e.dictionary; for (let t = 0, e = this.children.length; t < e; t++) { const e = this.children[t]; t > 0 && (e.outlineData.Prev = this.children[t - 1].dictionary), t < this.children.length - 1 && (e.outlineData.Next = this.children[t + 1].dictionary), e.endOutline() } } return this.dictionary.end() } } var OutlineMixin = { initOutline() { return this.outline = new PDFOutline(this, null, null, null) }, endOutline() { if (this.outline.endOutline(), this.outline.children.length > 0) return this._root.data.Outlines = this.outline.dictionary, this._root.data.PageMode = "UseOutlines" } }; function ownKeys(t, e) { var i = Object.keys(t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(t); e && (n = n.filter((function (e) { return Object.getOwnPropertyDescriptor(t, e).enumerable }))), i.push.apply(i, n) } return i } function _objectSpread2(t) { for (var e = 1; e < arguments.length; e++) { var i = null != arguments[e] ? arguments[e] : {}; e % 2 ? ownKeys(Object(i), !0).forEach((function (e) { _defineProperty(t, e, i[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : ownKeys(Object(i)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e)) })) } return t } function _defineProperty(t, e, i) { return e in t ? Object.defineProperty(t, e, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = i, t } class PDFStructureContent { constructor(t, e) { this.refs = [{ pageRef: t, mcid: e }] } push(t) { t.refs.forEach((t => this.refs.push(t))) } } class PDFStructureElement { constructor(t, e, i = {}, n = null) { this.document = t, this._attached = !1, this._ended = !1, this._flushed = !1, this.dictionary = t.ref({ S: e }); const r = this.dictionary.data; (Array.isArray(i) || this._isValidChild(i)) && (n = i, i = {}), void 0 !== i.title && (r.T = new String(i.title)), void 0 !== i.lang && (r.Lang = new String(i.lang)), void 0 !== i.alt && (r.Alt = new String(i.alt)), void 0 !== i.expanded && (r.E = new String(i.expanded)), void 0 !== i.actual && (r.ActualText = new String(i.actual)), this._children = [], n && (Array.isArray(n) || (n = [n]), n.forEach((t => this.add(t))), this.end()) } add(t) { if (this._ended) throw new Error("Cannot add child to already-ended structure element"); if (!this._isValidChild(t)) throw new Error("Invalid structure element child"); return t instanceof PDFStructureElement && (t.setParent(this.dictionary), this._attached && t.setAttached()), t instanceof PDFStructureContent && this._addContentToParentTree(t), "function" == typeof t && this._attached && (t = this._contentForClosure(t)), this._children.push(t), this } _addContentToParentTree(t) { t.refs.forEach((({ pageRef: t, mcid: e }) => { this.document.getStructParentTree().get(t.data.StructParents)[e] = this.dictionary })) } setParent(t) { if (this.dictionary.data.P) throw new Error("Structure element added to more than one parent"); this.dictionary.data.P = t, this._flush() } setAttached() { this._attached || (this._children.forEach(((t, e) => { t instanceof PDFStructureElement && t.setAttached(), "function" == typeof t && (this._children[e] = this._contentForClosure(t)) })), this._attached = !0, this._flush()) } end() { this._ended || (this._children.filter((t => t instanceof PDFStructureElement)).forEach((t => t.end())), this._ended = !0, this._flush()) } _isValidChild(t) { return t instanceof PDFStructureElement || t instanceof PDFStructureContent || "function" == typeof t } _contentForClosure(t) { const e = this.document.markStructureContent(this.dictionary.data.S); return t(), this.document.endMarkedContent(), this._addContentToParentTree(e), e } _isFlushable() { return !(!this.dictionary.data.P || !this._ended) && this._children.every((t => "function" != typeof t && (!(t instanceof PDFStructureElement) || t._isFlushable()))) } _flush() { !this._flushed && this._isFlushable() && (this.dictionary.data.K = [], this._children.forEach((t => this._flushChild(t))), this.dictionary.end(), this._children = [], this.dictionary.data.K = null, this._flushed = !0) } _flushChild(t) { t instanceof PDFStructureElement && this.dictionary.data.K.push(t.dictionary), t instanceof PDFStructureContent && t.refs.forEach((({ pageRef: t, mcid: e }) => { this.dictionary.data.Pg || (this.dictionary.data.Pg = t), this.dictionary.data.Pg === t ? this.dictionary.data.K.push(e) : this.dictionary.data.K.push({ Type: "MCR", Pg: t, MCID: e }) })) } } class PDFNumberTree extends PDFTree { _compareKeys(t, e) { return parseInt(t) - parseInt(e) } _keysName() { return "Nums" } _dataForKey(t) { return parseInt(t) } } var MarkingsMixin = { initMarkings(t) { this.structChildren = [], t.tagged && (this.getMarkInfoDictionary().data.Marked = !0, this.getStructTreeRoot()) }, markContent(t, e = null) { if ("Artifact" === t || e && e.mcid) { let t = 0; for (this.page.markings.forEach((e => { (t || e.structContent || "Artifact" === e.tag) && t++ })); t--;)this.endMarkedContent() } if (!e) return this.page.markings.push({ tag: t }), this.addContent(`/${t} BMC`), this; this.page.markings.push({ tag: t, options: e }); const i = {}; return void 0 !== e.mcid && (i.MCID = e.mcid), "Artifact" === t && ("string" == typeof e.type && (i.Type = e.type), Array.isArray(e.bbox) && (i.BBox = [e.bbox[0], this.page.height - e.bbox[3], e.bbox[2], this.page.height - e.bbox[1]]), Array.isArray(e.attached) && e.attached.every((t => "string" == typeof t)) && (i.Attached = e.attached)), "Span" === t && (e.lang && (i.Lang = new String(e.lang)), e.alt && (i.Alt = new String(e.alt)), e.expanded && (i.E = new String(e.expanded)), e.actual && (i.ActualText = new String(e.actual))), this.addContent(`/${t} ${PDFObject.convert(i)} BDC`), this }, markStructureContent(t, e = {}) { const i = this.getStructParentTree().get(this.page.structParentTreeKey), n = i.length; i.push(null), this.markContent(t, _objectSpread2(_objectSpread2({}, e), {}, { mcid: n })); const r = new PDFStructureContent(this.page.dictionary, n); return this.page.markings.slice(-1)[0].structContent = r, r }, endMarkedContent() { return this.page.markings.pop(), this.addContent("EMC"), this }, struct(t, e = {}, i = null) { return new PDFStructureElement(this, t, e, i) }, addStructure(t) { const e = this.getStructTreeRoot(); return t.setParent(e), t.setAttached(), this.structChildren.push(t), e.data.K || (e.data.K = []), e.data.K.push(t.dictionary), this }, initPageMarkings(t) { t.forEach((t => { if (t.structContent) { const e = t.structContent, i = this.markStructureContent(t.tag, t.options); e.push(i), this.page.markings.slice(-1)[0].structContent = e } else this.markContent(t.tag, t.options) })) }, endPageMarkings(t) { const e = t.markings; return e.forEach((() => t.write("EMC"))), t.markings = [], e }, getMarkInfoDictionary() { return this._root.data.MarkInfo || (this._root.data.MarkInfo = this.ref({})), this._root.data.MarkInfo }, getStructTreeRoot() { return this._root.data.StructTreeRoot || (this._root.data.StructTreeRoot = this.ref({ Type: "StructTreeRoot", ParentTree: new PDFNumberTree, ParentTreeNextKey: 0 })), this._root.data.StructTreeRoot }, getStructParentTree() { return this.getStructTreeRoot().data.ParentTree }, createStructParentTreeNextKey() { this.getMarkInfoDictionary(); const t = this.getStructTreeRoot(), e = t.data.ParentTreeNextKey++; return t.data.ParentTree.add(e, []), e }, endMarkings() { const t = this._root.data.StructTreeRoot; t && (t.end(), this.structChildren.forEach((t => t.end()))), this._root.data.MarkInfo && this._root.data.MarkInfo.end() } }; const FIELD_FLAGS = { readOnly: 1, required: 2, noExport: 4, multiline: 4096, password: 8192, toggleToOffButton: 16384, radioButton: 32768, pushButton: 65536, combo: 131072, edit: 262144, sort: 524288, multiSelect: 2097152, noSpell: 4194304 }, FIELD_JUSTIFY = { left: 0, center: 1, right: 2 }, VALUE_MAP = { value: "V", defaultValue: "DV" }, FORMAT_SPECIAL = { zip: "0", zipPlus4: "1", zip4: "1", phone: "2", ssn: "3" }, FORMAT_DEFAULT = { number: { nDec: 0, sepComma: !1, negStyle: "MinusBlack", currency: "", currencyPrepend: !0 }, percent: { nDec: 0, sepComma: !1 } }; var AcroFormMixin = { initForm() { if (!this._font) throw new Error("Must set a font before calling initForm method"); this._acroform = { fonts: {}, defaultFont: this._font.name }, this._acroform.fonts[this._font.id] = this._font.ref(); let t = { Fields: [], NeedAppearances: !0, DA: new String(`/${this._font.id} 0 Tf 0 g`), DR: { Font: {} } }; t.DR.Font[this._font.id] = this._font.ref(); const e = this.ref(t); return this._root.data.AcroForm = e, this }, endAcroForm() { if (this._root.data.AcroForm) { if (!Object.keys(this._acroform.fonts).length && !this._acroform.defaultFont) throw new Error("No fonts specified for PDF form"); let t = this._root.data.AcroForm.data.DR.Font; Object.keys(this._acroform.fonts).forEach((e => { t[e] = this._acroform.fonts[e] })), this._root.data.AcroForm.data.Fields.forEach((t => { this._endChild(t) })), this._root.data.AcroForm.end() } return this }, _endChild(t) { return Array.isArray(t.data.Kids) && (t.data.Kids.forEach((t => { this._endChild(t) })), t.end()), this }, formField(t, e = {}) { let i = this._fieldDict(t, null, e), n = this.ref(i); return this._addToParent(n), n }, formAnnotation(t, e, i, n, r, s, o = {}) { let a = this._fieldDict(t, e, o); a.Subtype = "Widget", void 0 === a.F && (a.F = 4), this.annotate(i, n, r, s, a); let h = this.page.annotations[this.page.annotations.length - 1]; return this._addToParent(h) }, formText(t, e, i, n, r, s = {}) { return this.formAnnotation(t, "text", e, i, n, r, s) }, formPushButton(t, e, i, n, r, s = {}) { return this.formAnnotation(t, "pushButton", e, i, n, r, s) }, formCombo(t, e, i, n, r, s = {}) { return this.formAnnotation(t, "combo", e, i, n, r, s) }, formList(t, e, i, n, r, s = {}) { return this.formAnnotation(t, "list", e, i, n, r, s) }, formRadioButton(t, e, i, n, r, s = {}) { return this.formAnnotation(t, "radioButton", e, i, n, r, s) }, formCheckbox(t, e, i, n, r, s = {}) { return this.formAnnotation(t, "checkbox", e, i, n, r, s) }, _addToParent(t) { let e = t.data.Parent; return e ? (e.data.Kids || (e.data.Kids = []), e.data.Kids.push(t)) : this._root.data.AcroForm.data.Fields.push(t), this }, _fieldDict(t, e, i = {}) { if (!this._acroform) throw new Error("Call document.initForms() method before adding form elements to document"); let n = Object.assign({}, i); return null !== e && (n = this._resolveType(e, i)), n = this._resolveFlags(n), n = this._resolveJustify(n), n = this._resolveFont(n), n = this._resolveStrings(n), n = this._resolveColors(n), n = this._resolveFormat(n), n.T = new String(t), n.parent && (n.Parent = n.parent, delete n.parent), n }, _resolveType(t, e) { if ("text" === t) e.FT = "Tx"; else if ("pushButton" === t) e.FT = "Btn", e.pushButton = !0; else if ("radioButton" === t) e.FT = "Btn", e.radioButton = !0; else if ("checkbox" === t) e.FT = "Btn"; else if ("combo" === t) e.FT = "Ch", e.combo = !0; else { if ("list" !== t) throw new Error(`Invalid form annotation type '${t}'`); e.FT = "Ch" } return e }, _resolveFormat(t) { const e = t.format; if (e && e.type) { let i, n, r = ""; if (void 0 !== FORMAT_SPECIAL[e.type]) i = "AFSpecial_Keystroke", n = "AFSpecial_Format", r = FORMAT_SPECIAL[e.type]; else { let t = e.type.charAt(0).toUpperCase() + e.type.slice(1); if (i = `AF${t}_Keystroke`, n = `AF${t}_Format`, "date" === e.type) i += "Ex", r = String(e.param); else if ("time" === e.type) r = String(e.param); else if ("number" === e.type) { let t = Object.assign({}, FORMAT_DEFAULT.number, e); r = String([String(t.nDec), t.sepComma ? "0" : "1", '"' + t.negStyle + '"', "null", '"' + t.currency + '"', String(t.currencyPrepend)].join(",")) } else if ("percent" === e.type) { let t = Object.assign({}, FORMAT_DEFAULT.percent, e); r = String([String(t.nDec), t.sepComma ? "0" : "1"].join(",")) } } t.AA = t.AA ? t.AA : {}, t.AA.K = { S: "JavaScript", JS: new String(`${i}(${r});`) }, t.AA.F = { S: "JavaScript", JS: new String(`${n}(${r});`) } } return delete t.format, t }, _resolveColors(t) { let e = this._normalizeColor(t.backgroundColor); return e && (t.MK || (t.MK = {}), t.MK.BG = e), e = this._normalizeColor(t.borderColor), e && (t.MK || (t.MK = {}), t.MK.BC = e), delete t.backgroundColor, delete t.borderColor, t }, _resolveFlags(t) { let e = 0; return Object.keys(t).forEach((i => { FIELD_FLAGS[i] && (e |= FIELD_FLAGS[i], delete t[i]) })), 0 !== e && (t.Ff = t.Ff ? t.Ff : 0, t.Ff |= e), t }, _resolveJustify(t) { let e = 0; return void 0 !== t.align && ("number" == typeof FIELD_JUSTIFY[t.align] && (e = FIELD_JUSTIFY[t.align]), delete t.align), 0 !== e && (t.Q = e), t }, _resolveFont(t) { if (null === this._acroform.fonts[this._font.id] && (this._acroform.fonts[this._font.id] = this._font.ref()), this._acroform.defaultFont !== this._font.name) { t.DR = { Font: {} }; const e = t.fontSize || 0; t.DR.Font[this._font.id] = this._font.ref(), t.DA = new String(`/${this._font.id} ${e} Tf 0 g`) } return t }, _resolveStrings(t) { let e = []; function i(t) { if (Array.isArray(t)) for (let i = 0; i < t.length; i++)"string" == typeof t[i] ? e.push(new String(t[i])) : e.push(t[i]) } return i(t.Opt), t.select && (i(t.select), delete t.select), e.length && (t.Opt = e), Object.keys(VALUE_MAP).forEach((e => { void 0 !== t[e] && (t[VALUE_MAP[e]] = t[e], delete t[e]) })), ["V", "DV"].forEach((e => { "string" == typeof t[e] && (t[e] = new String(t[e])) })), t.MK && t.MK.CA && (t.MK.CA = new String(t.MK.CA)), t.label && (t.MK = t.MK ? t.MK : {}, t.MK.CA = new String(t.label), delete t.label), t } }, AttachmentsMixin = { file(t, e = {}) { e.name = e.name || t; const i = { Type: "EmbeddedFile", Params: {} }; let n; if (!t) throw new Error("No src specified"); if (Buffer.isBuffer(t)) n = t; else if (t instanceof ArrayBuffer) n = Buffer.from(new Uint8Array(t)); else { let e; if (e = /^data:(.*);base64,(.*)$/.exec(t)) e[1] && (i.Subtype = e[1].replace("/", "#2F")), n = Buffer.from(e[2], "base64"); else { if (n = fs.readFileSync(t), !n) throw new Error(`Could not read contents of file at filepath ${t}`); const { birthtime: e, ctime: r } = fs.statSync(t); i.Params.CreationDate = e, i.Params.ModDate = r } } e.creationDate instanceof Date && (i.Params.CreationDate = e.creationDate), e.modifiedDate instanceof Date && (i.Params.ModDate = e.modifiedDate), e.type && (i.Subtype = e.type.replace("/", "#2F")); const r = CryptoJS.MD5(CryptoJS.lib.WordArray.create(new Uint8Array(n))); let s; i.Params.CheckSum = new String(r), i.Params.Size = n.byteLength, this._fileRegistry || (this._fileRegistry = {}); let o = this._fileRegistry[e.name]; o && isEqual(i, o) ? s = o.ref : (s = this.ref(i), s.end(n), this._fileRegistry[e.name] = _objectSpread2(_objectSpread2({}, i), {}, { ref: s })); const a = { Type: "Filespec", F: new String(e.name), EF: { F: s }, UF: new String(e.name) }; e.description && (a.Desc = new String(e.description)); const h = this.ref(a); return h.end(), e.hidden || this.addNamedEmbeddedFile(e.name, h), h } }; function isEqual(t, e) { return t.Subtype === e.Subtype && t.Params.CheckSum.toString() === e.Params.CheckSum.toString() && t.Params.Size === e.Params.Size && t.Params.CreationDate === e.Params.CreationDate && t.Params.ModDate === e.Params.ModDate } class PDFDocument extends stream.Readable { constructor(t = {}) { switch (super(t), this.options = t, t.pdfVersion) { case "1.4": this.version = 1.4; break; case "1.5": this.version = 1.5; break; case "1.6": this.version = 1.6; break; case "1.7": case "1.7ext3": this.version = 1.7; break; default: this.version = 1.3 }this.compress = null == this.options.compress || this.options.compress, this._pageBuffer = [], this._pageBufferStart = 0, this._offsets = [], this._waiting = 0, this._ended = !1, this._offset = 0; const e = this.ref({ Type: "Pages", Count: 0, Kids: [] }), i = this.ref({ Dests: new PDFNameTree }); if (this._root = this.ref({ Type: "Catalog", Pages: e, Names: i }), this.options.lang && (this._root.data.Lang = new String(this.options.lang)), this.page = null, this.initColor(), this.initVector(), this.initFonts(t.font), this.initText(), this.initImages(), this.initOutline(), this.initMarkings(t), this.info = { Producer: "PDFKit", Creator: "PDFKit", CreationDate: new Date }, this.options.info) for (let t in this.options.info) { const e = this.options.info[t]; this.info[t] = e } this.options.displayTitle && (this._root.data.ViewerPreferences = this.ref({ DisplayDocTitle: !0 })), this._id = PDFSecurity.generateFileID(this.info), this._security = PDFSecurity.create(this, t), this._write(`%PDF-${this.version}`), this._write("%"), !1 !== this.options.autoFirstPage && this.addPage() } addPage(t) { null == t && ({ options: t } = this), this.options.bufferPages || this.flushPages(), this.page = new PDFPage(this, t), this._pageBuffer.push(this.page); const e = this._root.data.Pages.data; return e.Kids.push(this.page.dictionary), e.Count++, this.x = this.page.margins.left, this.y = this.page.margins.top, this._ctm = [1, 0, 0, 1, 0, 0], this.transform(1, 0, 0, -1, 0, this.page.height), this.emit("pageAdded"), this } continueOnNewPage(t) { const e = this.endPageMarkings(this.page); return this.addPage(t), this.initPageMarkings(e), this } bufferedPageRange() { return { start: this._pageBufferStart, count: this._pageBuffer.length } } switchToPage(t) { let e; if (!(e = this._pageBuffer[t - this._pageBufferStart])) throw new Error(`switchToPage(${t}) out of bounds, current buffer covers pages ${this._pageBufferStart} to ${this._pageBufferStart + this._pageBuffer.length - 1}`); return this.page = e } flushPages() { const t = this._pageBuffer; this._pageBuffer = [], this._pageBufferStart += t.length; for (let e of t) this.endPageMarkings(e), e.end() } addNamedDestination(t, ...e) { 0 === e.length && (e = ["XYZ", null, null, null]), "XYZ" === e[0] && null !== e[2] && (e[2] = this.page.height - e[2]), e.unshift(this.page.dictionary), this._root.data.Names.data.Dests.add(t, e) } addNamedEmbeddedFile(t, e) { this._root.data.Names.data.EmbeddedFiles || (this._root.data.Names.data.EmbeddedFiles = new PDFNameTree({ limits: !1 })), this._root.data.Names.data.EmbeddedFiles.add(t, e) } addNamedJavaScript(t, e) { this._root.data.Names.data.JavaScript || (this._root.data.Names.data.JavaScript = new PDFNameTree); let i = { JS: new String(e), S: "JavaScript" }; this._root.data.Names.data.JavaScript.add(t, i) } ref(t) { const e = new PDFReference(this, this._offsets.length + 1, t); return this._offsets.push(null), this._waiting++, e } _read() { } _write(t) { return Buffer.isBuffer(t) || (t = Buffer.from(t + "\n", "binary")), this.push(t), this._offset += t.length } addContent(t) { return this.page.write(t), this } _refEnd(t) { if (this._offsets[t.id - 1] = t.offset, 0 == --this._waiting && this._ended) return this._finalize(), this._ended = !1 } write(t, e) { const i = new Error("PDFDocument#write is deprecated, and will be removed in a future version of PDFKit. Please pipe the document into a Node stream."); return console.warn(i.stack), this.pipe(fs.createWriteStream(t)), this.end(), this.once("end", e) } end() { this.flushPages(), this._info = this.ref(); for (let t in this.info) { let e = this.info[t]; "string" == typeof e && (e = new String(e)); let i = this.ref(e); i.end(), this._info.data[t] = i } this._info.end(); for (let t in this._fontFamilies) { this._fontFamilies[t].finalize() } return this.endOutline(), this.endMarkings(), this._root.end(), this._root.data.Pages.end(), this._root.data.Names.end(), this.endAcroForm(), this._root.data.ViewerPreferences && this._root.data.ViewerPreferences.end(), this._security && this._security.end(), 0 === this._waiting ? this._finalize() : this._ended = !0 } _finalize() { const t = this._offset; this._write("xref"), this._write(`0 ${this._offsets.length + 1}`), this._write("0000000000 65535 f "); for (let t of this._offsets) t = `0000000000${t}`.slice(-10), this._write(t + " 00000 n "); const e = { Size: this._offsets.length + 1, Root: this._root, Info: this._info, ID: [this._id, this._id] }; return this._security && (e.Encrypt = this._security.dictionary), this._write("trailer"), this._write(PDFObject.convert(e)), this._write("startxref"), this._write(`${t}`), this._write("%%EOF"), this.push(null) } toString() { return "[object PDFDocument]" } } const mixin = t => { Object.assign(PDFDocument.prototype, t) }; mixin(ColorMixin), mixin(VectorMixin), mixin(FontsMixin), mixin(TextMixin), mixin(ImagesMixin), mixin(AnnotationsMixin), mixin(OutlineMixin), mixin(MarkingsMixin), mixin(AcroFormMixin), mixin(AttachmentsMixin), PDFDocument.LineWrapper = LineWrapper, module.exports = PDFDocument;
//# sourceMappingURL=/sm/ce14cfe33b99b709b4a0b6e2e419711fb321b51be4b8f3ea223e945c1ef2832e.map